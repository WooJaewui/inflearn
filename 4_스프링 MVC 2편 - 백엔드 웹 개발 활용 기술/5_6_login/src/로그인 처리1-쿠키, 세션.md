
# 로그인 처리1 - 쿠키, 세션.

------------------------------------------------------------------------------------------------------------------------------------------

> ## 프로젝트 생성.

### 도메인.
- 화면, UI, 기술 인프라 등등의 영역을 제외한 시스템이 구현해야 하는 핵심 비즈니스 업무 영역을 말함.
- 도메인이 가장 중요하다.
- 향후 web을 다른 기술로 바꾸어도 도메인은 그대로 유지할 수 있어야 한다. (도메인은 web을 참조하면 안된다)

------------------------------------------------------------------------------------------------------------------------------------------

> ## 로그인 처리하기 - 쿠키 적용.

### 쿠키.
- 서버에서 로그인에 성공하면 HTTP 응답에 쿠키를 담아서 브라우저에 전달하자.
- 브라우저는 앞으로 해당 쿠키를 지속해서 보내준다.


### 쿠키에는 영속 쿠키와 세션 쿠키가 있다.
- 영속 쿠키 : 만료 날짜를 입력하면 해당 날짜까지 유지.
- 세션 쿠키 : 만료 날짜를 생략하면 브라우저 종료시까지만 유지. 


### 쿠키를 해제하는 방법.
- Max-age=0으로 변경.

------------------------------------------------------------------------------------------------------------------------------------------

> ## 쿠키와 보안 문제.

### 보안 문제.
- 쿠키 값은 임의로 변경될 수 있다.
  - 클라이언트가 쿠키를 강제로 변경하면 다른 사용자가 된다. (웹 브라우저 개발자 모드에서 변경 가능)
- 쿠키에 보관된 정보는 훔쳐갈 수 있다.
  - 이 정보가 웹 브라우저에도 보관되고, 네으퉈크 요청마다 계속 클라이언트에서 서버로 전달된다.
  - 쿠키의 정보가 나의 로컬 PC가 털릴 수도 있고, 네트워크 전송 구간에서 털릴 수도 있다.
- 해커가 쿠키를 한번 훔쳐가면 평생 사용할 수 있다.
  - 해커가 쿠키를 훔쳐가서 그 쿠키로 악의적인 요청을 계속 시도할 수 있다.


### 대안.
- 쿠키에 중요한 값을 노출하지 않고, 사용자 별로 예측 불가능한 임의의 토큰을 노출하고, 서버에서 토큰과 사용자 ID를 매핑해서 인식한다.
- 토큰은 해커가 임의의 값을 넣어도 찾을 수 없도록 예상 불가능 해야 한다.
- 해커가 토큰을 털어가도 시간이 지나면 사용할 수 없도록 서버에서 해당 토큰의 만료시간을 짧게 유지한다. (30분)
- 해킹이 의심되는 경우 서버에서 해당 토큰을 강제로 제거하면 된다.

------------------------------------------------------------------------------------------------------------------------------------------

> ## 세션 동작 방식.

### 목표.
- 쿠키의 문제를 해결하기 위해서는 중요한 정보를 서버에 저장해야 한다.
- 클라이언트와 서버는 추정 불가능한 임의의 식별자 값으로 연결해야 한다.
- 서버에 중요한 정보를 보관하고 연결을 유지하는 방법을 세션이라 한다.


### UUID.
- UUID는 추정이 불가능하다.


### 클라이언트와 서버 연결.
- 서버는 클라이언트에 "sessionId"라는 이름으로 세션 ID만 쿠키에 담아서 전달한다.
- 클라이언트는 쿠키 저장소에 "sessionId" 쿠키를 보관한다.


### 중요.
- 회원과 관련된 정보는 전혀 클라이언트에 전달하지 않는다.
- 오직 추정 불가능한 세션 ID만 쿠키를 통해 클라이언트에 전달한다.


### 정리.
- 세션을 사용해서 서버에서 중요한 정보를 관리하게 되었다.
  - 쿠키 값을 변조 가능 -> 예상 불가능한 복잡한 세션 ID를 사용한다.
  - 쿠키에 보관하는 정보는 클라이언트 해킹시 털릴 가능성이 있다 -> 세션 ID가 털려도 여기에는 중요한 정보가 없다.
  - 쿠키 탈취 후 사용 -> 해커가 토큰을 털어가도 시간이 지나면 사용할 수 없도록 서버에서 세션의 만료시간을 짧게 유지한다. 

------------------------------------------------------------------------------------------------------------------------------------------

> ## 세션 직접 만들기.

### 세션 기능.
1. 세션 생성.
2. 세션 조회.
3. 세션 만료.


### 세션 생성.
- sessionId 생성. (임의의 추정 불가능한 값.)
- 세션 장소에 sessionId와 보관할 값 저장.
- sessionId로 응답 쿠키를 생성해서 클라이언트에 전달


### 세션 조회.
- 클라이언트가 요청한 sessionId 쿠키의 값으로, 세션 저장소에 보관한 값 조회.


### 세션 만료.
- 클라이언트가 요청한 sessionId 쿠키의 값으로, 세션 저장소에 보관한 sessionId와 값 제거.

------------------------------------------------------------------------------------------------------------------------------------------

> ## 직접 만든 세션 적용.

### 정리.
- 세션이 뭔가 특별한 것이 아니라 쿠키를 사용하는데, 서버에서 데이터를 유지하는 방법일 뿐이다.
- 프로젝트마다 세션을 직접 개발하면 불편하기 때문에, 서블릿에서 세션 개념을 지원한다.

------------------------------------------------------------------------------------------------------------------------------------------

> ## 서블릿 HTTP 세션1.

### HttpSession 소개.
- 서블릿이 제공하는 "HttpSession"도 결국 우리가 만든 "SeessionManager"와 같은 방식으로 동작한다.
- 서블릿을 통해 "HttpSession"을 생성하면 "JSESSIONID"가 생성된다.


### 세션 생성.
- request.getSession(true)
  - 세션이 있으면 기존 세션을 반환한다.
  - 세션이 없으면 새로운 세션을 생성해서 반환한다.
  - 기본값.
- request.getSession(false)
  - 세션이 있으면 기존 세션을 반환한다.
  - 세션이 없으면 새로운 세션을 생성하지 않는다. (null을 반환)


### 세션에 로그인 회원 정보 보관.
- 하나의 세션에 여러 개의 값을 보관할 수 있다.

------------------------------------------------------------------------------------------------------------------------------------------

> ## HTTP 세션2

### @SessionAttribute.
    @SessionAttribute( name = "loginMember", required = false ) Member loginMember
- 이미 로그인 된 사용자를 찾을 때 사용하면 된다.
- 이 기능은 세션을 생성하지 않는다.


### TrackingModes.
- 로그인을 처음 시도하면 "URL"에 "jsessionId"를 포함하고 있는 것을 확인할 수 있다.
- 웹 브라우저가 쿠키를 지원하지 않을 때 쿠키 대신 URL을 통해 세션을 유지하는 방법이다.
- URL 전달 방식을 끄고 항상 쿠키를 통해서만 세션을 유지하고 싶으면 "server.servlet.session.tracking-modes=cookie" 설정을 하면 된다.

------------------------------------------------------------------------------------------------------------------------------------------

> ## 세션 정보와 타임아웃 설정.

### 세션 관련 정보.
- sessionId : 세션 ID JSESSIONID의 값.
- maxInactiveInterval : 세션의 유효 시간. (1800초 = 30분)
- creationTime : 세션 생성일시.
- lastAccessedTime : 세션과 연결된 사용자가 최근에 서버에 접근한 시간. (클라이언트가 "JSESSIONID"로 요청한 경우 갱신)
- isNew : 새로 생성된 세션인지 확인.


### 세션 타임아웃 설정.
- 세션은 사용자가 로그아웃을 직접 호출해서 session.invalidate()를 호출한 경우 삭제된다.
- 대부분의 사용자는 로그아웃을 선택하지 않고, 그냥 웹 브라우저를 종료한다.
- 문제는 HTTP가 비 연결성이므로 서버 입장에서는 해당 사용자가 웹 브라우저를 종료한 것인지 아닌지 알 수 없다.
- 따라서, 서버에서 세션 데이터를 언제 삭제해야 되는지 판단하기가 어렵다.


### 남아 있는 세션의 문제점.
- "JSESSIONID"를 탈취 당했을 경우 오랜 시간이 지나도 해당 쿠키로 악의적인 요청을 할 수 있다.
- 세션은 기본적으로 메모리에 생성된다.
- 메모리의 크기가 무한하지 않기 때문에 꼭 필요한 경우만 생성해서 사용해야 한다.


### 세션의 종료 시점.
- "HttpSession"은 최근 요청한 시간을 기준으로 30분을 유지해준다.


### 글로벌 세션 타임아웃 설정.
    server.servlet.session.timeout=60 (60초)
- 글로벌 설정은 분 단위로 설정해야 한다.


### 특정 세션 단위로 시간 설정.
    session.setMax


### 세션 타임아웃.
- 세션의 타임아웃 시간은 해당 세션과 관련된 "JSESSIONID"를 전달하는 HTTP 요청이 있으면 현재 시간으로 다시 초기화 된다.
- session.getLastAccessedTime() : 최근 세션 접근 시간.


### 정리.
- 실무에서 주의할 점은 세션에는 최소한의 데이터만 보관해야 한다는 점이다.
- 보관한 데이터 용량 * 사용자 수로 세션의 메모리 사용량이 급격하게 늘어나서 장애로 이어질 수 있다.











