
# 트랜잭션 이해

----------------------------------------------------------------------------------------------------------------------------------

> ## 트랜잭션 - 개념 이해.

### 트랜잭션.
- 트랜잭션을 이름 그대로 번역하면 거래라는 뜻이다.
- 데이터베이스에서 트랜잭션은 하나의 거래를 안전하게 처리하도록 보장해주는 것을 뜻한다.


### 트랜잭션 커밋, 롤백.
- 커밋.
  - 모든 작업이 성공해서 테이터베이스에 정상 반영하는 것을 의미.
- 롤백.
  - 작업 중 하나라도 실패해서 거래 이전으로 되돌리는 것.


### ACID.
- 원자성 Atomicity
  - 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공 하거나 모두 실패해야 한다.
- 일관성 Consistency
  - 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다.
  - 예를 들어 데이터베이스에서 정한 무결성 제약 조건을 항상 만족해야 함.
- 격리성 Isolation
  - 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다.
  - 예를 들어 동시에 같은 데이터를 수정하지 못하도록 해야 한다.
  - 격리성은 동시성과 관련된 성능 이슈로 인해 트랜잭션 격리 수준(Isolation Level)을 선택할 수 있다.
- 지속성 Durability
  - 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다.
  - 중간에 시스템에 문제가 발생해도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 한다.


### 트랜잭션 격리성.
- 트랜잭션은 원자성, 일관성, 지속성을 보장한다.
- 트랜잭션 간에 격리성을 완벽히 보장하려면 트랜잭션을 거의 순서대로 실행해야 한다.
- 이렇게 하면 동시 처리 성능이 매우 나빠진다.
- 이런 문제로 인해 ANSI 표준은 트랜잭션의 격리 수준을 4단계로 나누어 정의한다.


### 트랜잭션 격리 수준  Isolation Level.
- READ UNCOMMITTED 커밋되지 않은 읽기
- READ COMMITTED 커밋된 읽기
- REPEATABLE READ 반복 가능한 읽기
- SERIALIZABLE 직렬화 가능.


### 참고.
- 강의에서는 일반적으로 많이 사용되는 READ COMMITTED 트랜잭션 격리 수준을 기준으로 설명한다.
- 트랜잭션 격리 수준은 데이터베이스에 자체에 관한 부분이어서 이 강의 내용을 넘어선다.

----------------------------------------------------------------------------------------------------------------------------------

> ## 데이터베이스 연결 구조와 DB 세션.

### 데이터베이스 연결 구조.
- 사용자는 웹 어플리케이션 서버(WAS)나 DB 접근 툴 같은 클라이언트를 사용해서 데이터베이스 서버에 접근할 수 있다.
- 클라이언트는 데이터베이스 서버에 연결을 요청하고 커넥션을 맺게 된다.
- 이때 데이터베이스 서버는 내부에 세션이라는 것을 만든다.
- 앞으로 해당 커넥션을 통한 모든 요청은 이 세션을 통해서 실행하게 된다.
- 세션은 트랜잭션을 시작하고, 커밋 또는 롤백을 통해 트랜잭션을 종료한다. 이후에 새로운 트랜잭션을 다시 시작할 수 있따.
- 사용자가 커넥션을 닫거나, 또는 DBA(DB 관리자)가 세션을 강제로 종료하면 세션은 종료된다.
- 커넥션 풀이 10개의 커넥션을 생성하면, 세션도 10개 만들어진다.

----------------------------------------------------------------------------------------------------------------------------------

> ## 트랜잭션 DB 예제1 - 개념 이해.

### 개요.
- 지금부터 설명하는 내용은 트랜잭션 개념의 이해를 돕기 위해 예시로 설명하는 것이다.
- 구체적인 실제 구현 방식은 데이터베이스마다 다르다.


### 트랜잭션 사용법.
- 데이터 변경 쿼리를 실행하고 결과를 반영하려면 커밋 명령어인 "commit"을 호출하고, 결과를 반영하고 싶지 않으면 "rollback"을 호출하면 된다.
- 커밋을 호출하기 전까지는 임시로 데이터를 저장하는 것이다.
- 따라서 해당 트랜잭션을 시작한 세션(사용자)에게만 변경 데이터가 보이고 다른 세션(사용자)에게는 변경 데이터가 보이지 않는다.
- 등록, 수정, 삭제 모두 같은 원리로 동작한다. 앞으로는 등록, 수정, 삭제를 간단히 변경이라는 단어로 표현하겠다.


### 커밋하지 않은 데이터를 다른 곳에서 조회할 수 있으면 어떤 문제가 발생할까?
- 세션 1이 만든 새로운 데이터가 세션 2가 조회했을 때 보이면 세션 2가 새로운 데이터에 관련된 기능을 사용한 후, 세션 1이 롤백하는 경우 문제.
- 따라서, 데이터 정합성에 큰 문제가 발생한다.

----------------------------------------------------------------------------------------------------------------------------------

> ## 트랜잭션 DB 예제2 - 자동 커밋, 수동 커밋.

### 자동 커밋.
    set autocommit true;
- 자동 커밋으로 설정하면 각각의 쿼리 실행 직후에 자동으로 커밋을 호출한다.
- 따라서 커밋이나 롤백을 직접 호출하지 않아도 되는 편리함이 있다.
- 하지만 쿼리를 하나하나 실행할 때마다 자동으로 커밋이 되어버리기 대문에 우리가 원하는 트랜잭션 기능을 제대로 사용할 수 없다.


### 수동 커밋.
    set autocommit false; 
- "commit, rollback"을 직접 호출해서 트랜잭션을 사용해야 한다.
- 수동 커밋 모드나 자동 커밋 모드는 한번 설정하면 해당 세션에서는 계속 유지된다. 중간에 변경하는 것은 가능하다.


### 참고.
- 수동 커밋 설정에서 "commit, rollback"을 호출하지 않으면 보통 트랜잭션 수행 시간에 설정되어 있어서 자동으로 rollback 된다.

----------------------------------------------------------------------------------------------------------------------------------

> ## 트랜잭션 DB 예제3 - 트랜잭션 실습.

### 정리.
- 커밋, 롤백 트랜잭션 실습.

----------------------------------------------------------------------------------------------------------------------------------

> ## 트랜잭션 DB 예제4 - 계좌이체.

### 정리.
- 계좌이체 예제를 통한 커밋, 롤백 트랜잭션 실습.
- 원자성.
  - 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공하거나 모두 실패해야 한다.
  - 트랜잭션의 원자성 때문에 하나의 작업인 것처럼 처리할 수 있었다.
- 오토 커밋.
  - 계좌이체 중간에 실패하면 문제가 발생한다.
- 트랜잭션 시작.
  - 따라서 이런 종류의 작업은 꼭 수동 커밋 모드를 사용해서 수동으로 커밋, 롤백 할 수 있도록 해야 한다.

----------------------------------------------------------------------------------------------------------------------------------

> ## DB 락 - 개념 이해.

### 개요.
- 세션1이 트랜잭션을 시작하고 데이터를 수정하는 동안 아직 커밋을 수행하지 않았는데, 세션2에서 동시에 같은 데이터를 수정하면 문제가 발생한다.
- 트랜잭션의 원자성이 깨진다.
- 이런 문제를 방지하려면, 세션이 트랜잭션을 시작하고 데이터를 수정하는 동안에는 커밋이나 롤백 전까지 다른 세션에서 데이터 수정을 막아야 한다.


### 락.
1. 세션1은 트랜잭션을 시작한다.
2. 세션1이 데이터 변경을 시도하면 로우의 락을 먼저 획득한다.
3. 세션1은 락을 획득했으므로 해당 로우에 update sql을 수행한다.
4. 세션2는 트랜잭션을 시작한다.
5. 세션2도 데이터 변경을 시도하면 해당 로우의 락을 먼저 획득해야 하는데 락이 없으므로 락이 돌아올 때까지 대기한다.
    - 락 대기 시간을 넘어가면 락 타이암웃 오류가 발생한다. (락 대기 시간은 설정할 수 있다)
6. 세션1은 커밋을 수행한다. 커밋으로 틀내잭션이 종료되었으므로 락도 반납한다.
7. 락을 획득하기 위해 대기하던 세션2가 락을 획득한다.
8. 세션2는 커밋을 수행하고 트랜잭션이 종료되었으므로 락을 반납한다.


### 참고.
- 락은 로우를 기준으로 사용되기 때문에 같은 로우의 변경이 일어나지 않으면 변경이 가능하다.

----------------------------------------------------------------------------------------------------------------------------------

> ## DB 락 - 변경.

### 락 타임아웃 설정.
    SET LOCK_TIMEOUT 600000;
- 락 타임아웃 설정 방법.


### 주의.
- 테스트 도중 락이 꼬이는 문제가 발생할 수 있다.
- 이럴 때는 H2 서버를 내렸다가 다시 올리자.

----------------------------------------------------------------------------------------------------------------------------------

> ## DB 락 - 조회.

### 일반적인 조회는 락을 사용하지 않는다.
- 보통 데이터를 조회할 때는 락을 획득하지 않고 바로 데이터를 조회할 수 있다.


### 조회와 락.
    SELECT FOR UPDATE 
- 데이터를 조회할 때도 락을 획득하고 싶을 때가 있다.
- 이렇게 하면 세션1이 조회 시점에 락을 가져가버리기 때문에 다른 세션에서 해당 데이터를 변경할 수 없다.


### 조회 시점에 락이 필요한 경우.
- 트랜잭션 종료 시점까지 해당 데이터를 다른 곳에서 변경하지 못하도록 강제로 막아야 할 때 사용한다.
- 예를 들어 어플리케이션 로직에서 "memberA"의 금액을 조회한 다음에 이 금액 정보로 어플리케이션에서 어떤 계산을 수행한다.


### 조회에 락을 가져오는 쿼리.
    SELECT * FROM 테이블이름 for update;


### 정리.
- 트랜잭션과 락은 데이터베이스마다 실제 동작하는 방식이 조금씩 다르기 때문에, 해당 데이터베이스 메뉴얼을 확인해보고 사용해야 한다.
- 트랜잭션과 락에 대한 더 깊이있는 내용은 JPA 책을 확인하자.

----------------------------------------------------------------------------------------------------------------------------------

> ## 트랜잭션 - 적용1.

### 테스트.
- 테스트에서 사용한 데이터를 모두 제거해야 여러 번 반복하더라도 오류가 발생하지 않는다.

----------------------------------------------------------------------------------------------------------------------------------

> ## 트랜잭션 - 적용2.

### 개요.
- 어플리케이션 트랜잭션을 어떤 계층에 걸어야 할까?
- 쉽게 이야기해서 트랜잭션을 어디에서 시작하고, 어디에서 커밋해야 할까?


### 트랜잭션 시작.
- 트랜잭션은 비즈니스 로직이 있는 서비스 계층에서 시작해야 한다.
- 비즈니스 로직이 잘못되면 해당 비즈니스 로직으로 인해 문제가 되는 부분을 함께 롤백해야 하기 때문이다.
- 트랜잭션을 시작하려면 커넥션이 필요하다. 
- 결국, 서비스 계층에서 커넥션을 만들고 로직을 수행한 후에 커밋/롤백 이후에 트랜잭션을 종료해야 한다.


### 커넥션 유지.
- 가장 단순한 방법은 커넥션을 파라미터로 전달해서 같은 커넥션이 사용되도록 유지하는 것이다.


### 주의.
- 커넥션 풀을 사용하는 경우 connection.close() 하면 커넥션이 종료되는 것이 아니라 풀에 반납된다.
- 그래서, close() 하기 전에 setAutocommit() 설정을 바꿔주는 것이 좋다.


### 남은 문제.
- 어플리케이션에서 DB 트랜잭션을 적용하려면 서비스 계층이 매우 지저분해진다.






















