
 # 데이터 접근 기술 - 테스트

---------------------------------------------------------------------------------------------------------------------------------

> ## 데이터베이스 연동

### 개요
- 데이터베이스에 연동하는 테스트에 대해서 알아보자
- 데이터 접근 기술은 실제 데이터베이스에 접근해서 데이터를 잘 저장하고 조회할 수 있는지 확인하는 것이 필요하다


### 설정 정보
- 테스트 케이스는 src/test에 있는 application.properties 설정 파일을 읽어서 실행한다


### @SpringBootTest
- @SpringBootApplication 이라는 어노테이션을 찾아서 설정으로 사용한다


### 참고
- 테스트에서 사용하는 데이터베이스 데이터는 외부의 변수없이 분리된 데이터여야 테스트를 원할하게 수행할 수 있다

---------------------------------------------------------------------------------------------------------------------------------

> ## 데이터베이스 분리

### 테스트의 원칙
1. 테스트는 다른 테스트와 격리해야 한다
2. 테스트는 반복해서 실행할 수 있어야 한다

---------------------------------------------------------------------------------------------------------------------------------

> ## 데이터 롤백

### 트랜잭션과 롤백 전략
- 테스트가 끝나고 나서 트랜잭션을 강제로 롤백해버리면 데이터가 깔끔하게 제거된다
- 트랜잭션을 활용하면 테스트가 끝나고 나서 데이터를 깔끔하게 원래 상태로 되돌릴 수 있다


### PlatformTransactionManager
- 트랜잭션을 꺼내서 사용할 수 있는 PlatformTransactionManager는 @Autowired를 통해 주입받을 수 있다


### @BeforeEach
- 각각의 테스트 케이스를 호출하기 전에 실행하는 코드는 작성할 수 있다


### @AfterEach
- 각각의 테스트 케이스가 완료된 직후에 호출된다

---------------------------------------------------------------------------------------------------------------------------------

> ## @Transactional

### @Transactional 원리
- 스프링이 제공하는 @Transactional 어노테이션은 로직이 성공적으로 수행되면 커밋하도록 동작한다
- 그런데 @Transactional 어노테이션을 테스트에서 사용하면 특별하게 동작한다
  - 테스트에 있으면 스프링은 테스트를 트랜잭션 안에서 실행하고, 테스트가 끝나면 트랜잭션을 자동으로 롤백시키셔 버린다


### @Transactional 동작 방식
1. 테스트에 @Transactional 어노테이션이 테스트 메서드나 클래스에 있으면 먼저 트랜잭션을 시작한다
2. 테스트 로직을 실행한다. 테스트가 끝날 때까지 모든 로직은 트랜잭션 안에서 수행된다
    - 트랜잭션은 기본적으로 전파되기 때문에, 리포지토리에서 사용하는 JdbcTemplate도 같은 트랜잭션을 사용한다
3. 테스트 실행 중에 INSERT SQL을 사용해서 item1, item2, item3을 데이터베이스에 저장한다
    - 물론 테스트가 리포지토리를 호출하고, 리포지토리는 JdbcTemplate을 사용해서 데이터를 저장한다
4. 검증을 위해서 SELECT SQL로 데이터를 조회한다. 여기서는 앞서 저장한 item1, item2, item3이 조회된다
5. @Transactional이 테스트에 있으면 테스트가 끝날때 트랜잭션을 강제로 롤백한다
6. 롤백에 의해 앞서 데이터베이스에 저장한 item1, item2, item3의 데이터가 제거된다


### 참고
- 트랜잭션을 여러 곳에서 설정한 경우 가장 먼저 시작한 트랜잭션을 같이 공유해서 사용한다
- 뒤에서 전파라는 개념을 통해 더 자세히 알아보자


### 강제 커밋시키는 방법
    @Commit
    @Rollback(false)
- @Transactional 어노테이션을 통해 자동 롤백되는 것을 막는 방법
- 입력된 데이터를 데이터베이스에서 실제로 확인하고 싶은 경우에 사용한다

---------------------------------------------------------------------------------------------------------------------------------

> ## 임베디드 모드 DB

### 임베디드 모드 Embedded mode
- 어플리케이션을 실행할 때 H2 데이터베이스도 해당 JVM 메모리에 포함해서 함께 실행할 수 있다
- DB를 어플리케이션에 내장해서 함께 실행한다고 해서 임베디드 모드라고 한다
- 쉽게 이야기해서 어플리케이션에서 자바 메모리를 함께 사용하는 라이브러리처럼 동작하는 것이다
  - 서버가 꺼지면 DB도 함께 꺼진다


### 테스터 데이터 설정
- @Profile("test")
  - 프로필이 test인 경우에만 데이터소스를 스프링 빈으로 등록한다
  - 테스트 케이스에서만 이 데이터소스를 스프링 빈으로 등록해서 사용하겠다는 뜻이다
- jdbc:h2:mem:db
  - 데이터소스를 만들 때 이렇게 적으면 임베디드 모드(메모리 모드)로 동작하는 H2 데이터베이스를 사용할 수 있다 
- DB_CLOSE_DELAY=-1
  - 임베디드 모드에서는 데이터베이스 커넥션 연결이 모두 끊어지면 데이터베이스도 종료되는데, 그것을 방지하는 설정이다


### 스프링 부트 - 기본 SQL 스크립트를 사용해서 데이터베이스를 초기화하는 기능
- src/test/resources/schema.sql 을 통해 테스트에서 사용할 설정 DDL을 작성해주면 자동으로 어플리케이션 실행시에 수행해 준다 

---------------------------------------------------------------------------------------------------------------------------------

> ## 스프링 부트와 임베디드 모드

### 개요
- 스프링 부트는 임베디드 데이터베이스에 대한 설정도 기본으로 제공한다
- 스프링 부트는 별다른 설정이 없으면 임베디드 데이터베이스를 사용한다


### 임베디드 데이터베이스 이름 고정
    application.properties
    spring.datasource.generate-unique-name=false
- 임베디드 데이터베이스 이름이 "jdbc:h2:mem:testdb"로 고정된다

























