
# 스프링 트랜잭션 전파1_기본

----------------------------------------------------------------------------------------------------------------------------------------

> ## 트랜잭션 두 번 사용

### 주의
- 로그를 보면 트랜잭션1과 트랜잭션2가 같은 'conn0' 커넥션을 사용하고 있다
- 이것은 중간에 커넥션 풀을 사용하기 때문이다
- 히카리 커넥션 풀에서 커넥션을 획득하면 실제 커넥션을 그대로 반환하는 것이 아니라 내부 관리를 위해 히카리 프록시 커넥션이라는 객체를 생성해서 반환한다
    - HikariProxyConnection@492002168
    - HikariProxyConnection@243860881

--------------------------------------------------------------------------------------------------------------------------------------

> ## 전파 기본

### 개요
- 트랜잭션을 각각 사용하는 것이 아니라, 트랜잭션이 이미 진행중인데, 여기에 추가로 트랜잭션을 수행하면 어떻게 될까?


### 외부 트랜잭션, 내부 트랜잭션
- 외부 트랜잭션
  - 먼저 시작된 트랜잭션
- 내부 트랜잭션
  - 외부 트랜잭션 안에서 수행된 트랜잭션
  - 기본동작 방식은 외부 트랜잭션에 참여하는 것이다 (하나의 트랜잭션처럼 실행됨)


### 물리 트랜잭션, 논리 트랜잭션
- 스프링은 이해를 돕기 위해 논리 트랜잭션과 물리 트랜잭션이라는 개념을 나눈다
- 물리 트랜잭션
  - 실제 데이터베이스에 적용되는 트랜잭션을 뜻한다
  - 실제 커넥션을 통해서 트랜잭션을 시작
- 논리 트랜잭션
  - 트랜잭션 매니저를 통해 트랜잭션을 사용하는 단위
  - 트랜잭션이 진행되는 중에 내부에 추가로 트랜잭션을 사용하는 경우에 나타난다
  - 단순히 트랜잭션이 하나인 경우 둘을 구분하지 않는다


### 원칙
- 모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋된다
- 하나의 논리 트랜잭션이라도 롤백되면 물리 트랜잭션을 롤백된다

--------------------------------------------------------------------------------------------------------------------------------------

> ## 전파 예제

### 트랜잭션 참여
- 내부 트랜잭션이 외부 트랜잭션에 참여한다는 뜻은 내부 트랜잭션이 외부 트랜잭션을 그대로 이어 받아서 따른다는 뜻이다
- 다른 관점으로 보면 외부 트랜잭션의 범위가 내부 트랜잭션까지 넓어진다는 뜻이다
- 외부에서 시작된 물리적인 트랜잭션의 범위가 내부 트랜잭션까지 넓어진다는 뜻이다
- 정리하면 외부 트랜잭션과 내부 트랜잭션이 하나의 물리 트랜잭션으로 묶이는 것이다


### isNewTransaction
- 새로 생성되는 외부 트랜잭션은 true
- 내부에서 만들어지는 내부 트랜잭션은 false


### 정리
- 스프링은 여러 트랜잭션이 함께 사용되는 경우, 처음 트랜잭션을 시작한 외부 트랜잭션이 실제 물리 트랜잭션 관리하도록 한다
- 외부 트랜잭션만 물리 트랜잭션을 커밋하고 롤백한다


### 요청 흐름 - 외부 트랜잭션
1. txManager.getTransaction()을 호출하면 외부 트랜잭션을 시작한다
2. 트랜잭션 매니저는 데이터소스를 통해 커넥션을 생성한다
3. 생성한 커넥션을 수동 커밋 모드(setAutoCommit(false))로 설정한다 (물리 트랜잭션 시작)
4. 트랜잭션 매니저는 트랜잭션 동기화 매니저에 커넥션을 보관한다
5. 트랜잭션 매니저는 트랜잭션을 생성한 결과를 "TransactionStatus"에 담아서 반환하는데, 여기에 신규 트랜잭션의 여부가 담겨 있다
6. 로직1이 사용되고, 커넥션이 필요한 경우 트랜잭션 동기화 매니저를 통해 트랜잭션이 적용된 커넥션을 획득해서 사용한다


### 요청 흐름 - 외부 트랜잭션
7. txManager.getTransaction()을 호출해서 내부 트랜잭션을 시작한다
8. 트랜잭션 매니저는 트랜잭션 동기화 매니저를 통해서 기존 트랜잭션이 존재하는지 확인한다
9. 기존 트랜잭션이 존재하므로 기존 트랜잭션에 참여한다
   - 기존 트랜잭션에 참여한다는 뜻은 거의 아무것도 하지 않는다는 뜻이다
   - 트랜잭션 동기화 매니저에 보관된 기존 커넥션을 사용한다
10. 트랜잭션 매니저는 트랜잭션을 생성한 결과를 "TransactionStatus"에 담아서 반환한다 (신규 트랜잭션 아님)
11. 로직2가 사용되고, 커넥션이 필요한 경우 트랜잭션 동기화 매니저를 통해 외부 트랜잭션이 보관한 커넥션을 획득해서 사용한다


### 응답 흐름 - 내부 트랜잭션
12. 로직2가 끝나고 트랜잭션 매니저를 통해 내부 트랜잭션을 커밋한다
13. 트랜잭션 매니저는 커밋 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다
    - 신규 트랜잭션이 아닌 경우 실제 커밋을 호출하지 않는다
    - 실제 커넥션에 커밋이나 롤백을 호출함녀 물리 트랜잭션이 끝나기 때문에 물리 트랜잭션은 외부 트랜잭션을 종료할 때까지 이어져야 한다


### 응답 흐름 - 외부 트랜잭션
14. 로직1이 끝나고 트랜잭션 매니저를 통해 외부 트랜잭션을 커밋한다
15. 트랜잭션 매니저는 커밋 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다
    - 외부 트랜잭션은 신규 트랜잭션이다
    - 신규 트랜잭션의 경우 DB 커넥션에 실제 커밋을 호출한다
16. 외부 트랜잭션의 경우 실제 데이터베이스에 커밋이 반영되고, 물리 트랜잭션도 끝난다


### 정리
- 여기서 핵심은 트랜잭션 매니저에 커밋을 호출한다고해서 항상 실제 커넥션에 물리 커밋이 발생하지는 않는다는 점이다
- 모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋될 수 있다

--------------------------------------------------------------------------------------------------------------------------------------

> ## 외부 롤백

### 요청 흐름
- 위에 내용과 같다


### 응답 흐름 - 내부 트랜잭션
1. 로직2가 끝나고 트랜잭션 매니저를 통해 내부 트랜잭션을 커밋한다
2. 트랜잭션 매니저는 커밋 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다
   - 실제 커넥션에 커밋이나 롤백을 호출하면 물리 트랜잭션이 끝나버린다


### 응답 흐름 - 외부 트랜잭션
3. 로직1이 끝나고 트랜잭션 매니저를 통해 외부 트랜잭션을 롤백한다
4. 트랜잭션 매니저는 롤백 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다
   - 외부 트랜잭션은 신규 트랜잭션이다
   - 따라서 DB 커넥션에 실제 롤백을 호출한다
5. 트랜잭션 매니저에 롤백하는 것이 논리적인 롤백이라면, 실제 커넥션에 롤백하는 것을 물리 롤백이라 할 수 있다

--------------------------------------------------------------------------------------------------------------------------------------

> ## 내부 롤백

### 실행 흐름
1. 외부 트랜잭션 시작
2. 내부 트랜잭션 시작
3. 내부 트랜잭션 롤백
    - 내부 트랜잭션을 롤백하면 실제 물리 트랜잭션은 롤백하지 않는다
    - 대신에 기존 트랜잭션을 롤백 전용으로 표시한다 (rollback-only)
4. 외부 트랜잭션 커믹
    - Global transaction is marked as rollback-only
    - 커밋을 호출했지만, 전체 트랜잭션이 롤백 전용으로 표시되어 있다 (물리 트랜잭션을 롤백)


### 응답 흐름 - 내부 트랜잭션
1. 로직2가 끝나고 트랜잭션 매니저를 통해 내부 트랜잭션을 롤백한다
2. 트랜잭션 매니저는 롤백 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다
3. 내부 트랜잭션은 물리 트랜잭션을 롤백하지 않는 대신에 트랜잭션 동기화 매니저에 "rollbackOnly=true"라는 표시를 해둔다


### 응답 흐름 - 외부 트랜잭션
4. 로직1이 끝나고 트랜잭션 매니저를 통해 외부 트랜잭션을 커밋한다
5. 트랜잭션 매니저는 커밋 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다
    - 트랜잭션 동기화 매니저에 "rollbackOnly-true" 표시가 있는지 확인하고, 표시가 있으면 물리 트랜잭션을 롤백한다
6. 실제 데이터베이스에 롤백이 반영되고, 물리 트랜잭션도 끝난다
7. 트랜잭션 매니저에 커밋을 호출한 개발자 입장에서는 분명 커밋을 기대했는데 롤백 전용 표시로 인해 실제로는 롤백이 된다


### 정리
- 논리 트랜잭션이 하나라도 롤백되면 물리 트랜잭션은 롤백된다
- 내부 논리 트랜잭션이 롤백되면 "rollbackOnly=true" 마크가 표시하고, 이 표시가 되어 있으면 물리 트랜잭션을 롤백한다


### 참고
- 어플리케이션 개발에서 중요한 기본 원칙은 모호함을 제거하는 것이다
- 이렇게 기대한 결과가 다른 경우 예외를 발생시켜서 명확하게 문제를 알려주는 것이 좋은 설계이다

--------------------------------------------------------------------------------------------------------------------------------------

> ## REQUIRES_NEW

### 개요
- 외부 트랜잭션과 내부 트랜잭션을 완전히 분리해서 사용하는 방법


### REQUIRED_NEW
- 외부 트랜잭션과 내부 트랜잭션을 분리하려면 내부 트랜잭션을 시작할 때 REQUIRED_NEW 옵션을 사용하면 된다


### Suspending current transaction
- 새로운 내부 트랜잭션을 생성하면 외부 트랜잭션을 잠시 미뤄두고 내부 트랜잭션이 동작한다


### 요청 흐름 - 외부 트랜잭션
1. txManager.getTransaction()를 호출해서 외부 트랜잭션을 시작한다
2. 트랜잭션 매니저는 데이터소스를 통해 커넥션을 생성한다
3. 생성한 커넥션을 수동 커밋 모드(setAutoCommit(false))로 설정한다 - 물리 트랜잭션 시작
4. 트랜잭션 매니저는 트랜잭션 동기화 매니저에 커넥션을 보관한다
5. 트랜잭션 매니저는 트랜잭션 생성한 결과를 TransactionStatus에 담아서 반환한다
6. 로직1 이 사용되고, 커넥션이 필요한 경우 트랜잭션 동기화 매니저를 통해 트랜잭션이 적용된 커넥션을 획득해서 사용한다


### 요청 흐름 - 내부 트랜잭션
7. REQUIRES_NEW 옵션과 함께 txManager.getTransaction()를 호출해서 내부 트랜잭션을 시작한다
8. 트랜잭션 매니저는 데이터소스를 통해 커넥션을 생성한다
9. 생성한 커넥션을 수동 커밋 모드(setAutoCommit(false))로 설정한다 - 물리 트랜잭션 시작
10. 트랜잭션 매니저는 트랜잭션 동기화 매니저에 커넥션을 보관한다
11. 트랜잭션 매니저는 신규 트랜잭션의 생성한 결과를 반환한다
12. 로직2가 사용되고, 커넥션이 필요한 경우 트랜잭션 동기화 매니저에 있는 "con2" 커넥션을 획득해서 사용한다


### 응답 흐름 - 내부 트랜잭션
1. 로직2가 끝나고 트랜잭션 매니저를 통해 내부 트랜잭션을 롤백한다
2. 트랜잭션 매니저는 롤백 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다
3. 내부 트랜잭션이 con2 물리 트랜잭션을 롤백한다
   - 이후에 "con1"의 보류가 끝나고, con1을 사용한다


### 응답 흐름 - 외부 트랜잭션
4. 외부 트랜잭션에 커밋을 요청한다
5. 외부 트랜잭션은 신규 트랜잭션이기 때문에 물리 트랜잭션을 커밋한다
6. 이 때 "rollbackOnly" 설정을 체크한다 "rollbackOnly" 설정이 없으므로 커밋한다
7. 본인이 만든 con1 커넥션을 통해 물리 트랜잭션을 커밋한다

--------------------------------------------------------------------------------------------------------------------------------------

> ## 다양한 전파 옵션

### REQUIRED
- 가장 많이 사용하는 기본 설정이다
- 기존 트랜잭션이 없으면 생성하고, 있으면 참여한다
  - 기존 트랜잭션 없음 : 새로운 트랜잭션을 생성한다
  - 기존 트랜잭션 있음 : 기존 트랜잭션에 참여한다


### REQUIRES_NEW
- 항상 새로운 트랜잭션을 생성한다
  - 기존 트랜잭션 없음 : 새로운 트랜잭션을 생성한다
  - 기존 트랜잭션 있음 : 새로운 트랜잭션을 생성한다


### SUPPORT
- 트랜잭션을 지원한다는 뜻이다
  - 기존 트랜잭션 없음 : 트랜잭션 없이 진행한다
  - 기존 트랜잭션 있음 : 기존 트랜잭션에 참여한다


### NOT_SUPPORT
- 트랜잭션을 지원하지 않는다는 의미인다
  - 기존 트랜잭션 없음 : 트랜잭션 없이 진행한다
  - 기존 트랜잭션 있음 : 트랜잭션 없이 진행한다 (기존 트랜잭션은 보류한다)


### MANDATORY
- 의무사항이다
- 트랜잭션이 반드시 있어야 한다
  - 기존 트랜잭션 없음 : IllegalTransactionStateException 예외 발생
  - 기존 트랜잭션 있음 : 기존 트랜잭션에 참여한다


### NEVER
- 트랜잭션을 사용하지 않는다는 의미이다
  - 기존 트랜잭션 없음 : 트랜잭션 없이 진행한다
  - 기존 트랜잭션 있음 : IllegalTransactionStateException 예외 발생


### NESTED
- 기존 트랜잭션 없음 : 새로운 트랜잭션을 생성한다
- 기존 트랜잭션 있음 : 중첩 트랜잭션을 만든다
  - 중첩 트랜잭션은 외부 트랜잭션의 영향을 받지만, 중첩 트랜잭션은 외부에 영향을 주지 않는다
  - 중첩 트랜잭션이 롤백 되어도 외부 트랜잭션은 커밋할 수 있다
  - 외부 트랜잭션이 롤백 되면 중첩 트랜잭션도 함께 롤백된다
- 참고
  - JDBC savepoint 기능을 사용한다. DB 드라이버에서 해당 기능을 지원하는지 확인이 필요하다
  - 중첩 트랜잭션은 JPA에서 사용할 수 없다


### 트랜잭션 전파와 옵션
- isolation, timeout, readOnly는 트랜잭션이 처음 시작될 때만 적용된다
- 트랜잭션에 참여하는 경우에는 적용되지 않는다


### 참고
- 실무에서 대부분 "REQUIRED"를 사용하고, 아주 가끔 "REQUIRES_NEW"를 사용하고, 나머지는 거의 사용하지 않는다




















