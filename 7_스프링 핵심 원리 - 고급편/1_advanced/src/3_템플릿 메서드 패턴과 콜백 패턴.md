
# 템플릿 메서드 패턴과 콜백 패턴 

-----------------------------------------------------------------------------------------------------------------------------------------

> ## 템플릿 메서드 패턴 - 시작

### 핵심 기능
- 해당 객체가 제공하는 공유의 기능
- 예 : 주문 로직 


### 부가 기능
- 핵심 기능을 보조하기 위해 제공되는 기능
- 예 : 로그 추적 로직, 트랜잭션 기능


### 변하는 것과 변하지 않는 것을 분리
- 좋은 설계는 변하는 것과 변하지 않는 것을 분리한느 것이다
- 이 둘을 분리해서 모듈화해야 한다.

-----------------------------------------------------------------------------------------------------------------------------------------

> ## 템플릿 메서드 패턴 - 적용1

### 제네릭 타입
    AbstractTemplate<Void> template = new ... {
        ...
        return null;
    };
- 반환할 값이 없으면 Void 클래스를 사용하면 된다.


### 정리.
- V0 : 핵심 기능만 있다
- V3 : 핵심 기능과 부가 기능이 함께 섞여 있다
- V4 : 핵심 기능과 템플릿을 호출하는 코드가 섞여 있다


### 좋은 설계란 ?
- 진정한 좋은 설계는 바로 "변경"이 일어날 때 자연스럽게 드러난다


### SRP 단일 책임 원칙
- 로그를 남기는 부분에 단일 책임을 지킨 것
- 변경 지점을 하나로 모아서 변경에 쉽게 대처할 수 있는 구조를 만들었다

-----------------------------------------------------------------------------------------------------------------------------------------

> ## 템플릿 메서드 패턴 - 정의

### 템플릿 메서드 패턴
- 템플릿 메서드를 사용하면 하위 클래스가 알고리즘의 구조를 변경하지 않고도 알고리즘의 특정 단계를 정의할 수 있다


### 템플릿 메서드 패턴의 단점
- 상속을 사용하기 때문에 상속에서 오는 단점들을 그대로 안고 간다
- 상속 단점
  - 자식 클래스가 부모 클래스와 컴파일 시점에 강하게 결합된다 (부모 클래스가 바뀌면 자식 클래스에 영향을 준다)


### 전략 패턴
- 템플릿 메서드 패턴과 비슷한 역할을 하면서 상속의 단점을 제거할 수 있는 디자인 패턴이다

-----------------------------------------------------------------------------------------------------------------------------------------

> ## 전략 패턴 - 예제2

### 람다 사용
- 람다는 인터페이스에 메서드가 1개만 있으면 사용할 수 있다


### 정리
- 변하지 않는 부분을 Context에 두고 변하는 부분을 Strategy를 구현해서 만든다 


### 선 조립, 후 실행 방식
- Context 와 Strategy를 실행 전에 원하는 모양으로 조립해두고, 그 다음에 Context를 실행하는 선 조립, 후 실행 방식에서 유용하다
- 장점
  - Context와 Strategy를 한번 조립하고 나면 Context를 실행하기만 하면 된다
- 단점
  - Context와 Strategy를 조립한 이후에는 전략을 변경하기가 번거롭다
  - Context에 setter를 제공해서 Strategy를 넘겨 받아 변경하면 되지만, Context를 싱글톤으로 사용할 떄는 동시성 이슈 등 고려할 점이 많다
  - 다양한 전략을 사용해야 하는 경우 Context를 하나 더 생성하고 그곳에 다른 Strategy를 주입하는 것이 더 나은 선택일 수 있다

-----------------------------------------------------------------------------------------------------------------------------------------

> ## 전략 패턴 - 예제3

### 템플릿
- 변하지 않는 부분을 템플릿, 그 템플릿 안에서 변하는 부분에 약간 다른 코드 조각을 넘겨서 실행하는 것이 목적이다
- 실행 시점에 유연하게 실행 코드 조각을 전달하는 ContextV2가 더 적합하다

-----------------------------------------------------------------------------------------------------------------------------------------

> ## 템플릿 콜백 패턴 - 시작

### 콜백 정의
- 프로그래밍에서 콜백 또는 콜애프러 함수는 다른 코드의 인수로서 넘겨주는 실행 가능한 코드를 말한다
- 콜백을 넘겨받는 코드는 이 콜백을 필요에 따라 즉시 실행할 수도 있고, 아니면 나중에 실행할 수도 있다


### 자바 언어에서 콜백
- 자바 언어에서 실행 가능한 코드를 인수로 넘기려면 객체가 필요하다 (자바 8부터는 람다 사용 가능)
- 자바 8 이전에는 보통 익명 내부 클래스를 통해 넘겨줬다
- 자바 8 이후에는 주로 람다를 사용한다


### 템플릿 콜백 패턴
- 스프링에서는 COntextV2와 같은 방식의 전략 패턴을 템플릿 콜백 패턴이라 한다 (GOF 디자인 패턴은 아니고, 스프링 내부에서 자주 사용)
- 스프링에서 "XXXTemplate"이 있다면 템플릿 콜백 패턴으로 만들어져 있다 생각하면 된다

-----------------------------------------------------------------------------------------------------------------------------------------

> ## 정리

### 한계
- 지금까지 설명한 방식의 한계는 아무리 최적화를 해도 결국 로그 추적기를 적용하기 위해서 원본 코드를 수정해야 한다


### 참고
- 지금까지 설명한 방식은 실제 스프링 안에서 많이 사용되는 방식이다
- "XXXTemplate"을 만나면 이번에 학습한 내용을 떠올려보면 어떻게 돌아가는지 쉽게 이해할 수 있을 것이다





