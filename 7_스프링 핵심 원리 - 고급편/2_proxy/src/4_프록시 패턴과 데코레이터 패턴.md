
# 프록시 패턴과 데코레이터 패턴

---------------------------------------------------------------------------------------------------------------------------------------

> ## 예제 프로젝트 만들기 v1

### 컨트롤러
- 스프링 MVC는 @RequestMapping, @Controller 어노테이션이 있어야 스프링 컨트롤러로 인식한다


### 비즈니스 로직
- request() : LogTrace를 적용할 대상
- noLOg() : LogTrace를 적용하지 않을 대상


### @Import
- 클래스를 스프링 빈으로 등록한다


### @SpringBootApplication(scanBasePackages = "경로")
- "@ComponentScan"의 기능과 같다
- 컴포넌트 스캔을 시작할 위치를 지정한다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 프록시, 프록시 패턴, 데코레이터 패턴 - 소개

### 클라이언트 서버
- 클라이언트 : 서버에 필요한 것을 요청
- 서버 : 클라이언트의 요청을 처리
- 컴퓨터 네트워크에 도입하면 클라이언트는 웹 브라우저, 요청을 처리하는 서버는 웹 서버가 된다


### 프록시 예시
- 엄마에게 라면을 사달라고 부탁 했는데, 엄마는 그 라면은 이미 집에 있다라고 할 수 있다 (접근 제어, 캐싱)
- 아버지께 자동차 주유를 부탁했는데, 아버지가 주유 뿐만 아니라 세차까지 하고 왔다 (부가 기능 추가)
- 대리자가 또 다른 대리자를 부를 수 있다 (프록시 체인)


### 대체 가능
- 서버와 프록시는 같은 인터페이스를 사용해야 한다
- 클라이언트가 사용하는 서버 객체를 프록시 객체로 변경해도 클라이언트 코드를 변경하지 않고 동작할 수 있어야 한다


### 프록시의 주요 기능
- 접근 제어
  - 권한에 따른 접근 차단
  - 캐싱
  - 지연 로딩
- 부가 기능 추가
  - 원래 서버가 제공하는 기능에 더해서 부가 기능을 수행한다
  - 예) 요청 값이나, 응답 값을 중간에 변형한다
  - 예) 실행 시간을 측정해서 추가 로그를 남긴다


### GOF 디자인 패턴
- 프록시 패턴 : 접근 제어가 목적
- 데코레이터 패턴 : 새로운 기능 추가가 목적
- 둘 다 프록시를 사용하는 방법이지만 GOF 디자인 패턴에서는 의도(intent)에 따라서 프록시 패턴과 데코레이터 패턴으로 구분한다


### 참고
- 프록시라는 개념은 클라이언트 서버라는 큰 개념안에서 자연스럽게 발생할 수 있다
- 객체안에서 객체로 구현되어있는가, 웹 서버로 구현되어 있는가처럼 규모의 차이가 있을 뿐 근본적인 역할은 같다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 프록시 패턴 - 예제 코드

### 정리
- 클라이언트는 프록시가 사용됐는지, 실제 객체가 사용됐는지 알지 못한다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 데코레이터 패턴 - 예제 코드

### 데코레이터 패턴
- 요청 값이나, 응답 값을 중간에 변형한다
- 실행 시간을 측정해서 추가 로그를 남긴다


### 데코레이터 체인
- 부가 기능을 여러 개 추가하는 경우

---------------------------------------------------------------------------------------------------------------------------------------

> ## 프록시 패턴과 데코레이터 패턴 정리

### 데코레이터
- 꾸며주는 역할을 하는 데코레이터들은 스스로 존재할 수 없다
- 객체에 추가 책임(기능)을 동적으로 추가하고 기능 확장을 위한 유연한 대안 제공


### 프록시
- 다른 개체에 대한 접근을 제어하기 위해 대리자를 제공

---------------------------------------------------------------------------------------------------------------------------------------

> ## 인터페이스 기반 프록시 - 적용

### 정리
- 프록시와 DI 덕분에 원본 코드를 전혀 수정하지 않고, 로그 추적기를 도입할 수 있었다
- 너무 많은 프록시 클래스를 만들어야 하는 단점이 있다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 구체 클래스 기반 프록시 - 적용

### 클래스 기반 프록시의 단점
- 자식 클래스에서 부모 클래스의 생성자를 무조건 호출해줘야 한다
- 부모 클래스에 기본 생성자가 없는 경우 부모 클래스의 선언된 생성자를 호출해줘야 한다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 인터페이스 기반 프록시와 클래스 기반 프록시

### 인터페이스 기반 프록시 vs 클래스 기반 프록시
- 인터페이스가 없어도 클래스 기반으로 프록시를 생성할 수 있다
- 클래스 기반 프록시는 해당 클래스에만 적용할 수 있다
- 인터페이스 기반 프록시는 인터페이스만 같으면 모든 곳에 적용할 수 있다
- 클래스 기반 프록시는 상속을 사용하기 때문에 몇가지 제약이 있다
  - 부모 클래스의 생성자를 호출해야 한다
  - 클래스에 final 키워드가 붙으면 상속이 불가능하다
  - 메서드에 final 키워드가 붙으면 해당 메서드를 오버라이딩 할 수 없다


### 인터페이스 기반 프록시의 단점
- 인터페이스가 필요하다는 점이다 (인터페이스가 없으면 만들 수 없다)
- 캐스팅 관련된 단점이 있는데, 강의 뒷부분에서 설명


### 참고
- 인터페이스를 도입하는 것은 구현을 변경할 가능성이 있을 때 효과적이다
- 구현을 변경할 가능성이 거의 없는 코드에 인터페이스를 추가하는 것은 번거롭고 실용적이지 않다 


### 결론
- 실무에서 프록시를 적용할 때, 인터페이스가 있는 경우 없는 경우 모두 있기 때문에 2가지 상황을 모두 대응할 수 있어야 한다


### 너무 많은 프록시 클래스
- 대상 클래스만 다를 뿐 로직이 모두 똑같다
- 프록시 클래스를 하나만 만들어서 모든 곳에 적용하는 방법은 없을까 ? => 동적 프록시 기술









