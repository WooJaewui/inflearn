
# 동적 프록시 기술

----------------------------------------------------------------------------------------------------------------------------------

> ## 리플렉션

### 리플렉션
- 클래스나 메서드의 메타정보를 사용해서 동적으로 호출하는 메서드를 변경할 수 있다


### 참고
- 람다를 사용해서 공통화 하는 것도 가능하다
- 여기서는 람다를 사용하기 어려운 상황이라 가정하자
- 그리고 리플렉션 학습이 목적이니 리플렉션에 집중하자


### 정리
- 정적인 target.callA(), callB() 코드를 리플렉션을 사용해서 "Method"라는 메타정보로 추상화했다.
- 덕분에 공통 로직을 만들 수 있게 되었다


### 주의
- 리플렉션을 사용하면 클래스와 메서드의 메타정보를 사용해서 어플리케이션의 동적으로 유연하게 만들 수 있다
- 하지만 리플렉션 기술은 런타임에 동작하기 때문에, 컴파일 시점에 오류를 잡을 수 없다
- 리플렉션은 일반적으로 사용하면 안된다
- 리플렉션은 프레임워크 개발이나 또는 매우 일반적인 공통 처리가 필요할 때 부분적으로 주의해서 사용해야 한다

----------------------------------------------------------------------------------------------------------------------------------

> ## JDK 동적 프록시 - 예제 코드

### InvocationHandler 인터페이스
- JDK 동적 프록시에 적용할 공통 로직을 개발할 수 있다


### 프록시 생성 방법
    Proxy.newProxyInstance(Ainterface.class.getClassLoader(), new Class[]{ AInterface.class }, handler);


### 정리
- 프록시는 JDK 동적 프록시를 사용해서 동적으로 만들었다

----------------------------------------------------------------------------------------------------------------------------------

> ## JDK 동적 프록시 - 적용1

### 런타임 객체 의존 관계
- JDK 동적 프록시를 빈으로 등록해서 프록시에서 공통 로직을 수행하고, 실제 객체의 메서드를 수행하도록 만듦

----------------------------------------------------------------------------------------------------------------------------------

> ## JDK 동적 프록시 - 적용2

### ProxyPatternUtils
    PatternUtils.matchPatter(패턴, 패턴을 확인할 String);


### JDK 동적 프록시 한계
- 인터페이스가 필수다
- 인터페이스 없이 클래스만 있는 경우에 어떻게 동적 프록시를 적용할 수 있을까?
- 일반적인 방법으로는 어렵고 "CGLIB"라는 바이트코드를 조작하는 특별한 라이브러리를 사용해야 한다

----------------------------------------------------------------------------------------------------------------------------------

> ## CGLIB - 소개

### CGLIB : Code Generator Library
- 바이트코드를 조작해서 동적으로 클래스를 생성하는 기술을 제공하는 라이브러리이다
- 인터페이스가 없어도 구체 클래스만 가지고 동적 프록시를 만들어낼 수 있다
- CGLIB는 원래는 외부 라이브러리인데, 스프링 프레임워크가 스프링 내부 소스 코드에 포함했다, 따라서 스프링을 사용하면 라이브러리 추가 없이 사용 가능

----------------------------------------------------------------------------------------------------------------------------------

> ## CGLIB - 예제 코드

### MethodInterceptor 인터페이스
- CGLIB를 사용하려면 구현해야 되는 인터페이스
- 동적 프록시에 InvocationHandler 같은 역할을 한다


### CGLIB가 생성한 프록시 클래스 이름
    대상클래스$$ EnhancerByCGLIB$$임의코드


### JDK proxy가 생성한 클래스 이름
    com.sun.proxy.$proxy1


### CGLIB 제약
- 클래스 기반 프록시는 상속을 사용하기 때문에 제약이 있다
  - 부모 클래스의 생성자를 체크해야 한다 (기본 생성자가 필요하다)
  - 클래스에 final 키워드가 붙으면 상속이 불간으하다 (CGLIB에서 예외 발생)
  - 메서드에 final 키워드가 붙으면 해당 메서드를 오버라이딩 할 수 없다 (프록시 로직이 동작하지 않는다)
    

### 참고
- V2 어플리케이션에 기본 생성자를 추가하고, setter()를 사용해서 주입하면 CGLIB를 적용할 수 있다


### 남은 문제
- 인터페이스가 있는 경우 JDK 동적 프록시를 적용하고, 그렇지 않은 경우에는 CGLIB를 적용하려면 어떻게 해야할까?









