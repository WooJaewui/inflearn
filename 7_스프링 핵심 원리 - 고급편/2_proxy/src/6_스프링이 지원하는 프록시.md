
# 스프링이 지원하는 프록시

-----------------------------------------------------------------------------------------------------------------------------------------

> ## 프록시 팩토리 - 소개

### 문제점
- 인터페에스가 있는 경우 JDK 동적 프록시를 적용, 그렇지 않은 경우 CGLIB를 적용해야 한다


### 스프링 해결 방법
- 스프링은 유사한 구체적인 기술들이 있을 때, 그것들을 통합해서 일관성 있게 접근할 수 있고, 더욱 편리하게 사용할 수 있는 추상화된 기술을 제공
- 스프링은 동적 프록시를 통합해서 편리하게 만들어주는 프록시 팩토리(ProxyFactory)라는 기능을 제공한다
- 프록시 팩토리는 인터페이스가 있으면 JDK 동적 프록시를 사용하고, 구체 클래스만 있으면 CGLIB를 사용한다 (설정을 통해 CGLIB만 사용할 수 있다)

-----------------------------------------------------------------------------------------------------------------------------------------

> ## 프록시 팩토리 - 예제 코드1

### Advice 만들기
- 프록시에 적용하는 부가 기능 로직이다
- JDK 동적 프록시 InvocationHandler와 CGLIB MethodInterceptor 개념과 유사하다

-----------------------------------------------------------------------------------------------------------------------------------------

> ## 프록시 팩토리 - 예제 코드2

### 정리
- 프록시 팩토리의 서비스 추상화 덕분에 구체적인 CGLIB, JDK 동적 프록시 기술에 의존하지 않고, 매우 편리하게 동적 프록시를 생성할 수 있다
- 프록시의 부가 기능 로직도 특정 기술에 종속적이지 않게 Advice 하나로 편리하게 사용할 수 있었다


### 참고
- 스프링 부트는 AOP를 적용할 때 기본적으로 proxyTargetClass=true 로 설정해서 사용한다
- 따라서 인터페이스가 있어도 항상 CGLIB를 사용해서 구체 클래스를 기반으로 프록시를 생성한다 (뒤에서 배움)

-----------------------------------------------------------------------------------------------------------------------------------------

> ## 포인트컷, 어드바이스, 어드바이저 - 소개

### 포인트컷 Pointcut
- 어디에 부가 기능을 적용할지, 어디에 부가 기능을 적용하지 않을지 판단하는 필터링 로직


### 어드바이스 Advice
- 이전에 본 것처럼 프록시가 호출하는 부가 기능이다 (프록시 로직)


### 어드바이저 Advisor
- 하나의 포인트컷과 하나의 어드바이스를 가지고 있는 것이다. (포인트컷1 + 어드바이스1)


### 역할과 책임
- 이렇게 구분한 것은 역할과 책임을 명확하게 분리한 것이다
- 포인트컷은 대상 여부를 확인하는 필터 역할만 담당한다
- 어드바이스는 깔끔하게 부가 기능 로직만 담당한다
- 이 둘을 합치면 어드바이저가 된다
- 스프링의 어드바이저는 하나의 포인트컷 + 하나의 어드바이스로 구성된다

-----------------------------------------------------------------------------------------------------------------------------------------

> ## 예제 코드1 - 어드바이저

### 어드바이저 등록
    proxyFactory.addAdvice(new TimeAdvice());
    proxyFactory.addAdvisor(Pointcut.TRUE, new TimeAdvice());
- Advice()를 등록하면 자동으로 Pointcut.TRUE로 어드바이저가 등록된다
- Pointcut.TRUE는 항상 true를 반환하는 포인트컷이다

-----------------------------------------------------------------------------------------------------------------------------------------

> ## 예제 코드2 - 직접 만든 포인트컷

### MethodMatcher 인터페이스
- matches() : 이 메서드에 method, targetClass 정보가 넘어온다. 이 정보로 어드바이스를 적용할지 적용하지 않을지 판단할 수 있따
- isRuntime() : 동적으로 넘어오는 매개변수를 판단 로직으로 사용할 수 있다 
  - false인 경우 캐싱을 통해 성능 향상이 가능하다
  - true인 경우 캐싱을 하지 않는다

-----------------------------------------------------------------------------------------------------------------------------------------

> ## 예제 코드3 - 스프링이 제공하는 포인트컷

### 스프링이 제공하는 포인트컷
- NameMatchMethodPointcut : 메서드 이름을 기반으로 매칭 (* 허용)
- JdkRegexpMethodPointcut : JDK 정규 표현식을 기반으로 포인트컷을 매칭한다
- TruePointcut : 항상 참을 반환한다
- AnnotationMatchingPointcut : 어노테이션으로 매칭한다
- AspectJExpressionPointcut : aspectJ 표현식으로 매칭한다


### 가장 중요한 것은 aspectJ 표현식
- 실무에서는 aspectJ 표현식을 기반으로 사용하는 AspectJExpressionPointcut을 사용한다

-----------------------------------------------------------------------------------------------------------------------------------------

> ## 예제 코드4 - 여러 어드바이저 함께 적용

### 여러 프록시의 문제
- 프록시를 여러 개 생성해야 한다는 문제가 있다
- 만약 적용해야 하는 어드바이저가 10개라면 10개의 프록시를 생성해야 한다


### 하나의 프록시, 여러 어드바이저
- 스프링은 이 문제를 해결하기 위해 하나의 프록시에 여러 어드바이저를 적용할 수 있도록 했다


### 중요
- 스프링 AOP를 처음 공부하거나 사용하면, AOP 적용 수 만큼 프록시가 생성된다고 착각하게 된다 (실제 많은 개발자들이 이렇게 생각하는 것을 봄)
- 스프링은 AOP를 적용할 때, 최적화를 진행해서 지금처럼 프록시는 하나만 만들고, 하나의 프록시에 여러 어드바이저를 적용한다
- 하나의 target에 여러 AOP가 동시에 적용되어도, 스프링 AOP는 "target"마다 하나의 프록시만 생성한다

-----------------------------------------------------------------------------------------------------------------------------------------

> ## 정리

### 정리
- 프록시 팩토리 덕분에 개발자는 매우 편리하게 프록시를 생성할 수 있게 되었다


### 남은 문제
- 너무 많은 설정
  - 설정 파일이 지나치게 많아진다 (config 파일)
- 컴포넌트 스캔
  - 컨포넌트 스캔을 사용하는 경우 지금까지 학습한 방법으로는 프록시 적요이 불가능하다
  - 실제 객체를 스프링 컨테이너에 빈으로 등록하는 것이 아니라, 부가 기능이 있는 프록시를 실제 객체 대신 스프링 컨테이너에 빈으로 등록해야 한다


### 빈 후처리기
- 위 두 가지 문제를 해결하는 방법이다
 











