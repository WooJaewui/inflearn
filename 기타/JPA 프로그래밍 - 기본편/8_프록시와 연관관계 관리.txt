
 프록시와 연관관계 관리.



 # 프록시.

프록시 기초.
● em.find( ) : 데이터베이스를 통해서 실제 엔티티 객체 조회.
● em.getReference( ) : 데이터베이스 조회를 미루는 가짜 엔티티( 프록시 ) 객체 조회.

프록시 특징.
● 실제 클래스를 상속 받아서 만들어짐.
● 실제 클래스와 겉 모양이 같다.
● 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 됨.
● 프록시 객체는 실제 객체의 참조를 보관.
● 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드 호출.

프록시 세부사항.
● 프록시 객체는 처음 사용할 떄 한 번만 초기화.
● 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님.
● 프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야함. ( instance of 사용 )
● 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 getReference( )를 호출해도 실제 엔티티 반환.
● 준영속 상태일 때, 프록시를 초기화 문제 발생.

JPA 클래스 비교 특징.
● 한 영속성 컨텍스트 안에서 같은 id로 가져온 엔티티는 항상 == 가 true여야 한다.
● getReference( ), find( ) 순서대로 함수를 실행하면 프록시 엔티티가 반환된다.
● find( ), getReference( ) 순서대로 함수를 실행하면 실제 엔티티가 반환된다.

프록시 확인.
프록시 초기화 여부 확인 : entityManagerFactory.getPersistenceUnitUtil( ).isLoaded( 엔티티 ) ;
프록시 클래스 확인 : 엔티티.getClass( ) ;
프록시 강제 초기화 : Hibernate.initailize( 엔티티 ) ; => JPA 표준에는 강제 초기화가 없음.



 # 즉시 로딩과 지연 로딩.

지연 로딩 설정.
● @ManyToOne( fetch = FetchType.LAZY )

즉시 로딩 설정.
● @ManyToOne( fetch = FetchType.EAGER )
● 엔티티를 모두 조인해서 가져옴.

프록시와 즉시로딩 주의.
● 가급적 지연 로딩만 사용. ( 특히 실무에서 )
● 즉시 로딩을 적용하면 예상하지 못한 SQL이 발생.
● 즉시 로딩은 JPQL에서 N+1 문제를 일으킨다.
● @ManyToOne , @OneToOne은 기본이 EAGER 로딩.
● @OneToMany , @ManyToMany는 기본이 LAZY 로딩.

지연로딩을 해야하는 이유.
● 여러개의 엔티티들이 연결되어 있는 경우 항상 모든 엔티티를 조인해서 데이터를 SELECT한다. ( 성능 문제 )
● JPQL N + 1문제 => 하나의 SELECT로 처리할 수 있는 상황을 여러 개의 SELECT로 처리하는 문제가 발생.

fetch 조인.
개념.
	● 한번에 두 개 이상의 엔티티를 조인해서 SELECT 하는 경우에 사용한다.
	● 사용하지 않는 엔티티는 지연로딩으로 사용.
쿼리.
	● SELECT A FROM MEMBER A JOIN FETCH A.TEAM

지연 로딩 활용.
실무에서는 지연로딩으로만 생성한다.
필요한 경우에 fetch join을 사용.



 # 영속성 전이 : CASCADE.

CASCADE.
● 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을 때 사용.
● 예 : 부모 엔티티를 저장할 때 자식 엔티티도 같이 저장.

설정하기.
● @OneToMany( cascade = CascadeType.ALL )

CASCADE 주의.
● 영속성 전이는 연관관계를 매핑하는 것과 아무 관련이 없음.
● 단일 엔티티와 연관되어 있는 경우에만 사용하는 것이 좋다.

CASCADE의 종류.
● ALL : 모두 적용.
● PERSIST : 영속. ( 저장할 때 )
● REMOVE : 삭제. ( 삭제할 때 )

고아 객체.
● 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제.
● @OneToMany( orphanRemovel = true )

고아 객체 주의.
● 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능.
● 참조하는 곳이 하나일 때 사용해야 함.
● 특정 엔티티가 개인 소유할 때 사용.
● CASCADE와 함께 사용하면 부모 엔티티에서 자식 엔티티 생명주기를 결정할 수 있다.



 # 실전 예제 5 - 연관관계 관리.

정리.
● @ManyToOne과 @OneToOne의 모든 연관관계를 LAZY로 바꿔줘야 한다.





