
# API 개발 고급 - 컬렉션 조회 최적화

----------------------------------------------------------------------------------------------------------------------------------

> ## 주문 조회 V2 : 엔티티를 DTO로 변환

### 주의
- Dtd 안에 엔티티 변수를 사용하면 안된다
- 엔티티 스펙이 노출된다

----------------------------------------------------------------------------------------------------------------------------------

> ## 주문 조회 V3 : 엔티티를 DTO로 변환 - 페치 조인 최적화

### fetch join - 컬렉션 연관 관계
- 일대다 관계에서 fetch join을 사용하려면, select 절에 distinct를 걸어줘야 중복을 제거해준다
- DB distinct와 다르다 (DB : 모든 컬럼이 같아야 중복 제거, fetch join : 컬렉션 join에 대한 뻥튀기 데이터 중복을 제거해준다)
- 단점 : 페이징 불가능 


### 일대다 관계에서 페이징
- 데이터를 메모리에 올린 후에, 페이징 처리한다 (join 뻥튀기 때문에 DB에서 페이징 처리할 수 없다)
- 데이터 건 수가 많아지면 StackOverflow가 발생할 수 있다


### 참고
- 컬렉션 페치 조인(1:다)는 1개만 사용할 수 있다 
- 둘 이상의 페치 조인을 사용하면 안된다 (데이터가 부정합하게 조회될 수 있다)

----------------------------------------------------------------------------------------------------------------------------------

> ## 주문 조회 V3.1 : 엔티티를 DTO로 변환 - 페이징과 한계 돌파

### 페이징과 한계 돌파
- 컬렉션을 페치 조인하면 페이징이 불가능하다
  - 컬렉션을 페치 조인하면 일대다 조인이 발생하므로 데이터가 예측할 수 없이 증가한다
  - 일대다에서 일(1)을 기준으로 페이징을 하는 것이 목적이다
  - 그런데, 데이터는 다(N)를 기준으로 row가 생성된다
- 이 경우 하이버네이트는 경고 로그를 남기고 모든 DB 데이터를 읽어서 메모리에서 페이징을 시도한다
- 최악의 경우 장애로 이어질 수 있다


### 한계 돌파
- ToOne(OneToOne, ManyToOne) 관계를 모두 페치조인 한다, ToOne 관계는 row 수를 증가시키지 않으므로 페이징 쿼리에 영향을 주지 않는다
- 컬렉션은 지연 로딩으로 조회한다
- 지연 로딩 성능 최적화를 위해 @BatchSize를 적용한다
  - hibernate.default_batch_fetch_size : 글로벌 설정
  - @BatchSize : 개별 최적화
  - 이 옵션을 사용하면 컬렉션이나, 프록시 객체를 한꺼번에 설정한 size 만큼 IN 쿼리로 조회한다


### @BatchSize
- 지연 로딩 설정되어 있는 엔티티라도, @BatchSize()로 설정한 값을 미리 조회한다


### application.yml 설정
    hibernate:
      default_batch_fetch_size : 100
- N + 1 쿼리 문제를 WHERE IN 절을 통해 해결할 수 있다
- 최대 IN 개수를 지정할 수 있다


### @BatchSize
- 장점
  - 쿼리 호출 수가 '1 + n' -> '1 + 1'로 최적화 된다
  - 조인보다 DB 데이터 전송량이 최적화된다
  - 페치 조인 방식과 비교해서 쿼리 호출 수가 약간 증가하지만, DB 데이터 전송량이 감소한다
  - 컬렉션 페치 조인은 페이징이 불가능 하지만 이 방법은 페이징이 가능하다
- 결론
  - ToOne 관계는 페치 조인해도 페이징에 영향을 주지 않는다
  - 따라서 ToOne 관계는 페치조인으로 쿼리 수를 줄이고 해결하고, 나머지는 "hibernate.default_batch_fetch_size"로 최적화 하자


### default_batch_fetch_size 크기 참고
- 100 ~ 1000 사이를 선택하는 것을 권장한다
- 10으로 설정하면, DB와 application의 순간 부하는 줄어들지만, 요청 쿼리 수가 많아지므로 성능이 떨어진다
- 1000으로 설정하는 것이 성능상 가장 좋지만, DB 또는 application의 순간 부하를 어디까지 견딜 수 있는지로 결정하면 된다

----------------------------------------------------------------------------------------------------------------------------------

> ## 주문 조회 V5 : JPA에서 DTO 직접 조회 - 컬렉션 조회 최적화

### 쿼리
- 루트 1번, 컬렉션 1번
- ToOne 관계들을 먼저 조회하고, 식별자로 ToMany 관계를 한꺼번에 조회
- Map을 사용해서 매칭 성능 향상 (O(1))

----------------------------------------------------------------------------------------------------------------------------------

> ## 주문 조회 V6 : JPA에서 DT로 직접 조회, 플랫 데이터 최적화

### V6 장단점
- 장점
  - 쿼리 1번
- 단점
  - 쿼리는 한번이지만 조인으로 인해 DB에서 어플리케이션에 전달하는 데이터에 중복 데이터가 추가되므로 상황에 따라 V5보다 더 느릴 수 있다
  - 어플리케이션에서 추가 작업이 크다
  - 페이징 불가능

----------------------------------------------------------------------------------------------------------------------------------

> ## API 개발 고급 정리

### 엔티티 조회
- 엔티티 스펙이 변하면, API 스펙이 변하므로 사용하지 말자
- 엔티티 조회 후 DTO로 변환 (V2)
- 페치 조인으로 쿼리 수 최적화 (V3)
- 컬렉션 페이징과 한계 돌파 (V3.1)
  - 컬렉션은 페치 조인시 페이징이 불가능
  - ToOne 관계는 페치 조인으로 쿼리 수 최적화
  - 컬렉션은 페치 조인 대신에 지연 로딩을 유지하고, hibernate.default_batch_fetch_size 로 최적화


### DTO 직접 조회
- JPA에서 DTO를 직접 조회 (V4)
- 컬렉션 조회 최적화 (V5)
  - 일대다 관계인 컬렉션은 IN w렁르 활용해서 메모리에 미리 조회해서 최적화
- 플랫 데이터 최적화 (V6)
  - JOIN 결과를 그대로 조회 후 어플리케이션에서 원하는 모양으로 직접 변환


### 권장 순서
1. 엔티티 조회 방식으로 우선 접근
   - 페치조인으로 쿼리 수를 최적화
   - 컬렉션 최적화
     - 페이징 필요 : @BatchSize로 최적화
     - 페이징 필요 X : 페치 조인 사용
2. 엔티티 조회 방식으로 해결이 안되면 DTO 조회 방식 사용
3. DTO 조회 방식으로 해결이 안되면 NativeSQL or 스프링 JdbcTemplate


### 참고
- 개발자는 성능 최적화와 코드 복잡도 사이에서 줄타기를 해야 한다
- 엔티티 조회 방식은 JPA가 많은 부분을 최적화 해주기 때문에, 단순한 코드를 유지하면서, 성능을 최적화할 수 있다
- 반면에 DTO 조회 방식은 SQL을 직접 다루는 것과 유사하기 때문에, 둘 사이에서 줄타기를 해야 한다


### DTO 조회 방식의 선택지
- 조회 쿼리가 1번 실행된다고 V6가 항상 좋은 방법인 것은 아니다
- V4는 코드가 단순하다. 특정 주문 한건만 조회하면 이 방식을 사용해도 성능이 잘 나온다
- V5는 코드가 복잡한다. 여러 주문을 한꺼번에 조회하는 경우에는 V4 대신에 V5를 사용하는 것이 좋다
- V6는 완전히 다른 접근방식이다. 쿼리 1번 수행, Order 기준으로 페이징 불가능, V5와 성능 차이 미비


























