
# 쿼리 메소드 기능

-------------------------------------------------------------------------------------------------------------------------------------

> ## 메소드 이름으로 쿼리 생성

### 쿼리 메서드 기능 3가지
1. 메서드 이름으로 쿼리 생성
2. 메서드 이름으로 JPA NamedQuery 호출
3. "@Query" 어노테이션을 사용해서 Repository 인터페이스에 쿼리 직접 정의


### 쿼리 메소드 필터 조건
- Spring Data JPA DOC에서 "query creation" 검색


### 쿼리 메소드 기능
- 조회
  - find...By, read...By, query...By, get...By
- COUNT
  - count..By
  - 반환타입 'long'
- EXISTS
  - exists...By
  - 반환타입 'boolean'
- 삭제
  - delete...By, remove...By
  - 반환타입 'long'
- DISTINCT
  - findDistinct, findMemberDistinctBy
- LIMIT
  - findFirst3, findFirst, findTop, findTop3


### 참고
- 엔티티의 필드명이 변경되면 메서드 이름도 꼭 함께 변경해야 한다
- 그렇지 않으면 어플리케이션이 실행될 때 오류가 발생한다

-------------------------------------------------------------------------------------------------------------------------------------

> ## JPA NamedQuery

### 예시 코드
    @NamedQuery(
        name = "Member.findByUsername",
        query = "select m from Member m where m.username = :username"
    )

    // Spring JPA
    List<Member> findByUsername(String username) {
        return em.createNamedQuery("Member.findByUsername", Member.class)
                    .setParameter("username", username)
                    .getResultList();
    }
    
    // Spring Data Jpa
    @Query(name = "Member.findByUsername")
    List<Member> findByUsername(@Param("username") String username);


### Spring Data JPA 관례
- @Query()보다 메서드 이름을 먼저 확인하고 namedQuery에서 지정한 이름과 메서드 이름을 매핑한다


### NamedQuery 장점
- 어플리케이션 로딩 시점에 쿼리를 파싱해보고 문법에 오류가 있으면 Exception이 발생한다

-------------------------------------------------------------------------------------------------------------------------------------

> ## @Query, 리포지토리 메서드에 쿼리 정의하기

### 예시 코드
    @Query("select m from Member m where m.username = :username")
    List<Member> findMember(@Param("username") String username);

-------------------------------------------------------------------------------------------------------------------------------------

> ## @Query, 값, DTO 조회하기

### 값 조회하기
    @Query("select m.username from Member m")
    List<String> ...

### DTO 조회하기
    @Query("select new 패키지이름.DTO이름(파라미터, ...) from Member m join m.team t")

-------------------------------------------------------------------------------------------------------------------------------------

> ## 파라미터 바인딩

### 파라미터 바인딩 종류
    // 위치 기반
    select m from Member m where m.username = ?0
  
    // 이름 기반
    select m from Member m where m.username = :username
- 특별한 이유가 없다면 이름 기반으로 사용하자


### 컬렉션 파라미터 바인딩
    @Query("select m from Member m where m.username in :names")
    List<Member> 

-------------------------------------------------------------------------------------------------------------------------------------

> ## 반환 타입

### 반환 타입
- 컬렉션
- Optional
- 엔티티
- 기타...
- Spring Data JPA document "Supported query keywords" 검색 


### 컬렉션
- 조회 쿼리에 결과값이 없으면 빈 컬렉션을 반환한다


### 단건
- 조회 쿼리에 결과값이 없으면 null을 반환한다
- 조회 쿼리에서 2개 이상의 데이터가 조회되면 IncorrectResultSizeDataAccessException이 발생한다

-------------------------------------------------------------------------------------------------------------------------------------

> ## 순수 JPA 페이징과 정렬

### 페이징과 정렬 파라미터
- org.springframework.data.domain.Sort : 정렬 기능
- org.springframework.data.domain.Pageable : 페이징 기능 (내부에 Sort 포함)


### 특별한 반환 타입
- org.springframework.data.domain.Page : 추가 count 쿼리 결과를 포함하는 페이징
- org.springframework.data.domain.Slice : 추가 count 쿼리 없이 다음 페이지만 확인 가능 (내부적으로 limit + 1 조회)
- List (자바 컬렉션) : 추가 count 쿼리 없이 결과만 반환


### 페이징 사용하기
    PageRequest pageRequest = PageRequest.of(페이지, 데이터 개수, Sort.by(Sort.Direction.DESC, "username"));
    Page<Member> page = memberRespotiry.findByAge(age, pageRequest);
    
    // 데이터
    List<Member> findMembers = page.getContents();
    // 총 개수
    long totalCount = page.getTotalElements();
    // 페이지 
    long pageNumber = page.getNumber();
    // 전체 페이지 수
    long totalPages = page.getTotalPages();


### count 쿼리 성능 최적화
    @Query(value = "일반 쿼리", countQuery = "select count(m.id) from Member m")
- Join으로 개수가 달라지지 않는 쿼리인 경우, join을 생략하고 쿼리를 수행하면 성능을 최적화할 수 있다 
- @Query 어노테이션에 countQuery 속성을 통해 count 조회 쿼리를 정의할 수 있다


### Page와 DTO 변환
    Page<MemberDto> pageMemberDto = page.map(m -> new MemberDto(...));
    
-------------------------------------------------------------------------------------------------------------------------------------

> ## 벌크성 수정 쿼리

### @Modifying
- executeUpdate() 역할을 해준다


### 벌크성 update 주의사항
- 벌크성 쿼리를 수행한 후에는 항상 em.clear() 해줘야 한다
- 영속성 컨텍스트에는 벌크성 쿼리가 반영이 되지 않는다
- @Modifying(clearAutomatically = true)를 통해 벌크성 쿼리 이후에 em.clear()를 자동으로 수행하도록 만들 수 있다

-------------------------------------------------------------------------------------------------------------------------------------

> ## @EntityGraph

### N + 1 해결방법
- fetch join
- default_batch_fetch_size


### fetch join 쉽게 만드는 방법
    // 메서드에 적용
    @EntityGraph(attributePaths = {"item"})
    // 클래스에 적용
    @NamedEntityGraph(name = "Member.all", attributeNodes = @NamedAttributeNode("team"))

-------------------------------------------------------------------------------------------------------------------------------------

> ## JPA Hint & Lock

### JPA Hint
- JPA 쿼리 힌트(SQL 힌트가 아니라 JPA 구현체에게 제공하는 힌트)


### JPA Hint 예시
    @QueryHints(value = @QueryHint(name = "org.hibernate.readOnly", value = "true"))
- 읽기만 하려는 조회 쿼리에 사용
- 변경 감지를 하지 않음 (성능 최적화)


### JPA Hint 주의사항
- 생각보다 성능이 엄청 빨라지지 않는다
- 테스트 후 적용해보자


### Lock
- @Lock(LockModeType.PESSIMISTIC_WRITE)
- 비관적 쓰기 : 조회 쿼리에 락을 건다 (for update) 
- 나중에 필요할 때 따로 찾아보기











