
# 확장 기능

--------------------------------------------------------------------------------------------------------------------------------

> ## 사용자 정의 리포지토리 구현

### 사용자 정의 리포지토리 구현
    // MemberRepository
    public interface MemberRepository extends JpaRepository<엔티티, ID>, MemberRepositoryCustom {
    }

    // MemberRepositoryCustom
    public interface MemberRepositoryCustom {
    }

    // MemberRespositoryImpl
    public class MemberRepositoryImpl implments MemberRepositoryCustom {
        ...
    }
- MemberRepository 인터페이스의 구현체를 만들어야 하는 경우 사용한다 (항상 필요한 것은 아님)
- 구현체의 이름은 꼭 MemberRepositoryImpl 이라는 이름으로 만들어야 한다


### 구현체의 이름 변경
    @EnableJpaRepositories(basePackages = "study.datajpa.repository", repositoryImplementationPostfix = "Impl")
- 기본값은 Impl을 붙이는 것
- repositoryImplementationPostfix = "값"을 변경해서 구현체의 이름을 변경할 수 있다


### 참고
- 복잡한 쿼리를 수행해야 하는 경우 Custom 구현체를 직접 만드는 것이 아니라, 클래스를 새로 만드는 방법도 좋은 방법이다
- MemberQueryRepository 클래스를 새로 만드는 것!

--------------------------------------------------------------------------------------------------------------------------------

> ## Auditing

### Auditing
- 엔티티를 생성, 변경할 때 변경한 사람과 시간을 추적하고 싶으면


### @MappedSuperclass
    @MappedSuperclass
- 엔티티에 공통 매핑 정보가 필요할 때 사용한다
- Member에 @MappedSuperclass를 설정한 클래스를 상속받으면, @MappedSuperclass가 붙은 클래스의 변수들을 DB 컬럼에 추가한다


### JPA 주요 이벤트 어노테이션
- @PrePersist : persist() 전에 실행할 메서드
- @PreUpdate : update() 전에 실행할 메서드
- @PostPersist : persist() 후에 실행할 메서드
- @PostUpdate : update() 후에 실행할 메서드


### Spring Data Jpa Auditing 설정
- @EnableJpaAuditing
  - 스프링 부트 Application에 넣어줘야 함
- @CreatedDate, @LastModifiedDate
  - createDate, LastModifiedDate 변수에 작성해줘야 함
- @CreatedBy, @LastModifiedBy
  - 스프링 부트 Application에 AuditorAware<String> 빈을 등록해야 함
  - @AuditorAware 생성시 getCurrentAuditor() 메서드를 정의하는 데, 이 때 Session에서 Member id를 꺼내오도록 짜야 됨
- @EntityListeners(AuditingEntityListener.class)


### XML로 관리하기
    <?xml version="1.0" encoding="UTF-8"?>
    <entity-mappings xmlns="http://xmlns.jcp.org/xml/ns/persistence/orm"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence/
          orm http://xmlns.jcp.org/xml/ns/persistence/orm_2_2.xsd"
          version="2.2">
      <persistence-unit-metadata>
        <persistence-unit-defaults>
          <entity-listeners>
            <entity-listener class="org.springframework.data.jpa.domain.support.AuditingEntityListener"/>
          </entity-listeners>
        </persistence-unit-defaults>
      </persistence-unit-metadata>
    </entity-mappings>
- META-INF/orm.xml 폴더 생성

--------------------------------------------------------------------------------------------------------------------------------

> ## Web 확장 - 도메인 클래스 컨버터

### 도메인 컨버터 사용
- HTTP 요청은 "id"를 받지만 도메인 클래스 컨버터가 중간에 동작해서 회원 엔티티 객체를 반환
- 도메인 클래스 컨버터도 리파지토리를 사용해서 엔티티를 찾음


### 주의
- 도메인 클래스 컨버터로 엔티티를 파라미터로 받으면, 이 엔티티는 단순 조회용으로만 사용해야 한다
- 트랜잭션이 없는 범위에서 엔티티를 조회했으므로, 엔티티를 변경해도 DB에 반영되지 않는다

--------------------------------------------------------------------------------------------------------------------------------

> ## Web 확장 - 확장 페이징과 정렬 

### page
    @GetMapping("/members")
    public Page<Member> list(Pageable pageable) {
      return memberRepository.findAll(pageable);
    }
- url 파라미터
  - page=1 : 페이지 수
  - size=5 : 페이지에 나올 데이터 개수
  - sort=username,desc : desc 정렬 (asc 기본값)


### page 글로벌 설정
    // application.yml
    data.web.pageable.default-page-size: 10
    data.web.pageable.max-page-size: 2000


### @Qualifier
- 페이징 정보가 둘 이상이면 접두사로 구분


### Page를 1부터 시작하기
1. Pageable, Page를 파라미터와 응답 값으로 사용하지 않는다 (Custom Page, Pageable 지정해야 된다)
2. spring.data.web.pageable.one-indexed-parameters: true (인덱스가 1부터 시작됨)
  - 한계
    - Page안에 있는 pageNumber, Pageable 객체들의 값은 인덱스를 0부터 시작함
  
  



