
# 나머지 기능들

---------------------------------------------------------------------------------------------------------------------------------

> ## Specification 명세

### 술어 predicate
- 참 또는 거짓으로 평가
- AND OR 같은 연산자로 조합해서 다양한 검색조건을 쉽게 생성 (컴포지트 패턴)


### Specification 
- DDD 에서 나온 개념이다
- JPA Criteria를 내부적으로 사용한다 


### 참고
- JPA Criteria는 실무에서 사용하지 않는다, QueryDSL을 사용하자 (Criteria 문법이 어려움)

---------------------------------------------------------------------------------------------------------------------------------

> ## Query By Example

### JPA 관련 기능들 추가할지
- 모든 JOIN이 잘 되는지 확인하자


### Example
- Probe : 필드에 데이터가 있는 실제 도메인 객체
- ExampleMatcher : 특정 필드를 일치시키는 상세한 정보 제곤, 재사용 가능
- Example : Probe와 ExampleMatcher로 구성, 쿼리를 생성하는 데 도움


### 장점
- 동적 쿼리를 편리하기 처리
- 도메인 객체를 그대로 사용
- 데이터 저장소를 RDB에서 NoSQL로 변경해도 코드 변경이 없게 추상화 되어 있음
- 스프링 데이터 JPA JpaRepository 인터페이스에 이미 포함


### 단점
- 조인은 가능하지만 내부 조인(INNER JOIN)만 가능함, 외부 조인(LEFT JOIN) 안됨
- 다음과 같은 중첩 제약 조건 안됨
  - firstname = ?0 or (firstname = ?1 and lastname = ?2)
- 매칭 조건이 매우 단순함
  - 문자는 starts/contains/ends/regex
  - 다른 속성은 정확한 매칭 '='만 지원


### 정리
- 실무에서 사용하기에는 매칭 조건이 너무 단순하고, LEFT 조인이 안됨

---------------------------------------------------------------------------------------------------------------------------------

> ## Projections

### 사용 시점
- 엔티티 대신에 DTO를 편리하게 조회할 떄 사용
- 전체 엔티티가 아니라 만약 회원 이름만 딱 조회하고 싶으면?


### Open Projection
- 조회 쿼리에서는 모든 데이터를 읽어오고, 엔티티에 원하는 데이터만 매칭한다


### Close Projection
- 조회 쿼리에서 원하는 데이터만 읽어온다


### 동적 프로젝션
    <T> List<T> findMemberByUsername(@Param("username") String username, Class<T> type);


### 중첩 Projection
    public interface NetedClosedProjections {
      String getUsername();
      TeamInfo getTeam();

      interface TeamInfo() {
        String getName();
      }
    }
- 외부 엔티티 Projections은 정상적으로 동작한다
- 내부 엔티티는 엔티티의 모든 컬럼을 조회한다


### 주의
- 프로젝션 대상이 root 엔티티면, JPQL SELECT 절 최적화 가능
- 프로젝션 대상이 root가 아니면
  - LEFT OUTER JOIN 처리
  - 모든 필드를 SELECT해서 엔티티로 조회한 다음에 계산


### 정리
- 프로젝션 대상이 root 엔티티면 유용하다
- 프로젝션 대상이 root 엔티티를 넘어가면 JPQL SELECT 최적화가 안된다
- 실무의 복잡한 쿼리를 해결하기에는 한계가 있다
- 실무에서는 단순할 때만 사용하자

---------------------------------------------------------------------------------------------------------------------------------

> ## 네이티브 쿼리

### 들어가기
- 가급적 네이티브 쿼리는 사용하지 않는게 좋음, 정말 어쩔 수 없을 때 사용


### 스프링 데이터 JPA 기반 네이티브 쿼리
- 페이징 지원
- 반환 타입
  - Object[]
  - Tuple
  - DTO (스프링 데이터 인터페이스 Projections 지원)
- 제약
  - Sort 파라미터를 통한 정렬이 정상 동작하지 않을 수 있음 (믿지 말고 직접 처리)
  - JPQL처럼 어플리케이션 로딩 시점에 문법 확인 불가
  - 동적 쿼리 불가


### 네이티브 쿼리
- 네이티브 SQL을 DTO로 조회할 때는 JdbcTemplate or MyBatis 권장


### Projections 활용
    @Query(value = "select * from member ...", countQuery = "select count(*) from member", nativeQuery = true) 
    Page<Member> findMember(Pageable pageable);


### 동적 네이티브 쿼리
- 하이버네이트를 직접 활용
- 스프링 JdbcTemplate, myBatis, jooq 같은 외부 라이브러리 사용


### 하이버네이트 동적 쿼리 예시
    String sql = select m.username as username from member m";

    List<MemberDto> result = em.createNativeQuery(sql)
                  .setFirstResult(0)
                  .setMaxResults(10)
                  .unwrap(NativeQuery.class)
                  .addScalar("username")
                  .setResultTransformer(Transformers.aliasToBean(MemberDto.class))
                  .getResultList();

















