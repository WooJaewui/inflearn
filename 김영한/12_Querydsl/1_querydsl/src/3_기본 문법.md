
# 기본 문법

---------------------------------------------------------------------------------------------------------------------------------

> ## 시작 - JPQL vs Querydsl

### QueryDsl 예시
    @Autowired
    EntityManager em;

    ...
    @Test
    void querydslTest() {
        JpaQueryFactory queryFactory = new JpaQueryFactory(em);
        QMember member = QMember.member;
        
        Member findMember = queryFactory.selectFrom(member)
                                .where(member.username.eq("member1"))
                                .fetchOne();
    }
- 문법 오류가 있으면 컴파일 오류가 발생한다


### JPAQueryFactory
- 멀티쓰레드 환경에서 문제 없이 설계되어 있다 (변수로 설정해서 사용할 수 있다)

---------------------------------------------------------------------------------------------------------------------------------

> ## 기본 Q-Type 활용

### Q클래스 인스턴스 사용하는 방법
    // 별칭 직접 지정
    QMember member = new QMember("별칭");
    // 기본 인스턴스 사용
    QMember member = QMember.member
- 별칭을 직접 지정하는 경우는, 같은 테이블을 조인해서 사용하는 경우에만 구분하기 위해 사용한다
- QMember.member는 static 변수이기 때문에 static Import를 활용해서 코드를 줄일 수 있다


### application.yml
    jap:
        properties:
            hibernate:
                use_sql_comments: true
- SQL로 변하기 전 JPQL 문법도 보여준다

---------------------------------------------------------------------------------------------------------------------------------

> ## 검색 조건 쿼리

### JPQL이 제공하는 모든 검색 조건
- eq() : =
- ne() : !=
- eq().not() : !=
- isNotNull() : is not null
- in() : in
- notIn() : not in
- between(a,b) : between
- goe() : >=
- gt() : >
- loe() : <=
- lt() : <
- like() : like
- contains() : like '%문자%'
- startsWith() : like '문자%'

---------------------------------------------------------------------------------------------------------------------------------

> ## 결과 조회

### 결과 조회
- fetch()
  - 리스트 조회, 데이터 없으면 빈 리스트 반환
- fetchOne()
  - 단 건 조회
  - 결과가 없으면 null, 결과가 둘 이상이면 NonUniqueResultException
- fetchFirst()
  - limit(1).fetchOne()
- fetchResults
  - 페이징 정보 포함
  - total count 쿼리 추가 실행
- fetchCount()
  - count 쿼리로 변경해서 count 수 조회

---------------------------------------------------------------------------------------------------------------------------------

> ## 정렬

### 예시 코드
    .orderBy(Member.age.desc(), member.username.asc().nullsLast())

---------------------------------------------------------------------------------------------------------------------------------

> ## 페이징

### 예시 코드
    .orderBy(member.username.desc())
    .offset(2)
    .limit(1)
    .fetch();
- offset : 시작
- limit : 데이터 개수


### 주의 사항
- count 쿼리는 성능상 따로 작성하는 것이 좋을 때도 있다 (JOIN이 많은 경우)

---------------------------------------------------------------------------------------------------------------------------------

> ## 집합

### 집합
- 결과값을 List<Tuple>로 반환한다


### Tuple 사용
    Tuple tuple = result.get(0);
    tuple.get(member.count());
    tuple.get(member.age.max());
    tuple.get(member.age.avg());
    tuple.get(member.age.min());

---------------------------------------------------------------------------------------------------------------------------------

> ## 조인 - 기본 조인

### 기본 조인 
- 조인의 기본 문법은 첫 번째 파라미터에 조인 대상을 지정하고, 두 번째 파라미터에 별칭으로 사용할 타입을 지정하면 된다


### 테스트
- extracting
  - 객체 안에 변수의 값을 확인할 때 사용
- contains
  - 중복 여부, 순서에 관계 없이 값만 일치하면 테스트 성공
- containsOnly
  - 순서, 중복을 무시하는 대신 원소값과 갯수가 정확히 일치
- containsExactly
  - 순서를 포함해서 정확하게 일치해야 한다


### 세타 조인
    queryFactory
        .select(member)
        .from(member, team)
        .where(member.username.eq(team.name))
        .fetch();
- 연관관계가 없는 필드로 조인
- from 절에 여러 엔티티를 선택해서 세타 조인할 수 있다
- 외부 조인 불가능 -> 다음에 설명할 조인 on을 사용하면 외부 조인 가능

---------------------------------------------------------------------------------------------------------------------------------

> ## 조인 - on절

### ON 절을 활용한 조인
1. 조인 대상 필터링
2. 연관관계 없는 엔티티 외부 조인


### JOIN과 ON절
- INNER JOIN은 ON절에 작성하는 것과 where 절에 조건을 작성하는 것이 똑같다
- OUTER JOIN에서만 ON절이 의미가 있다


### 연관관계 없는 엔티티 외부 조인
- on 절을 사용해서 서로 관계가 없는 필드로 외부 조인하는 기능이 추가되었다


### 주의
    // 일반 조인
    leftJoin(member.team, team)
    // 연관관계 없는 on 조인
    leftJoin(team).on(member.username.eq(team.name))

---------------------------------------------------------------------------------------------------------------------------------

> ## 조인 - 페치 조인

### 페치 조인
- SQL 조인을 활용해서 연관된 엔티티를 SQL 한번에 조회하는 기능이다
- 주로 성능 최적화에 사용하는 방법이다

---------------------------------------------------------------------------------------------------------------------------------

> ## 서브 쿼리

### 서브 쿼리
    com.querydsl.jpa.JPAExpressions 사용


### JPAExpressions
    QMember memberSub = new QMember("memberSub");
    queryFactory
        .selectFrom(member)
        .where(member.age.eq(
            JPAExpression
                .select(memberSub.age.max())
                .from(memberSub)
        ))
        .fetch();


### querydsl 한계
- from 절의 서브쿼리 한계


### from 절의 서브쿼리 해결방안
- 서브쿼리를 join으로 변경한다 (가능한 상황도 있고, 불가능한 상황도 있다)
- 어플리케이션에서 쿼리를 2번 분리새서 실행한다
- nativeSQL을 사용한다


### 참고
- 쿼리에서 from 절 안에 서브 쿼리가 많다면, 쿼리를 잘 짠건지 확인해봐라! (Java에서 처리할 수 없는지 체크)

---------------------------------------------------------------------------------------------------------------------------------

> ## Case 문

### Case 기본 문법
    queryFactory
        .select(
            member.age
                .when(10).then("열살")
                .when(20).then("스무살")
                .otherwise("기타)
        )
        ...


### case 복잡한 문법
    queryFactory
        .select(
            new CaseBuilder()
                .when(member.age.between(0, 10).then("0~10살")
                .when(member.age.between(11, 20).then("11~20살")
                .otherwise("기타")
        )
        ...


### 참고
- DB에서 데이터 쿼리 문법은 되도록 처리하지 말고, Java에서 처리하자 

---------------------------------------------------------------------------------------------------------------------------------

> ## 상수, 문자 더하기

### 상수
    .select(member.username, Expressions.concat("A"))
    ...


### 문자 더하기
    ...
        .select(member.username.concat("_").concat(member.age.stringValue())
    ...
- stringValue()를 사용하면 문자가 아닌 타입을 문자로 바꿀 수 있다 (enum 등을 사용할 때 많이 활용)














