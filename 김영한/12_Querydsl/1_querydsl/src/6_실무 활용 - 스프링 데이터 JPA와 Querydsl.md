
# 실무 활용 - 스프링 데이터 JAP와 Querydsl

-----------------------------------------------------------------------------------------------------------------------------------

> ## 스프링 데이터 JPA 리포지토리로 변경

### 예시
    public interface MemberRepository extends JpaRepository<Member, Long> {
    }

-----------------------------------------------------------------------------------------------------------------------------------

> ## 사용자 정의 리포지토리

### 사용자 정의 리포지토리 사용법
1. 사용자 정의 인터페이스 작성
2. 사용자 정의 인터페이스 구현 (이름을 스프링 데이터 리포지토리 이름 + impl)
3. 스프링 데이터 리포지토리에 사용자 정의 인터페이스 상속


### 참고
- 특수한 조회 쿼리가 있는 경우, "MemberQueryRepository" 클래스를 따로 만들어 분리하는 것도 좋은 방법 중 하나이다

-----------------------------------------------------------------------------------------------------------------------------------

> ## 스프링 데이터 페이징 활용 1 - Querydsl 페이징 연동

### 스프링 데이터 페이징 활용
- 스프링 데이터의 Page, Pageable을 활용
- 전체 카운트를 한번에 조회하는 단순한 방법
- 데이터 내용과 카운트 쿼리를 따로 조회하는 방법


### 데이터 내용과 카운트 쿼리를 분리하는 이유
- 데이터 내용에 join, sub 쿼리 등이 복잡하게 되어 있지만, count()는 쉽게 구할 수 있는 경우 최적화를 위해 사용
- 데이터가 별로 없는 경우는 그냥 한번에 조회하는 방법을 사용하자

-----------------------------------------------------------------------------------------------------------------------------------

> ## 스프링 데이터 페이징 활용 2 - CountQuery 최적화

### 카운트 쿼리 생략
- 페이지 시작이면서 컨텐츠 사이즈가 페이지 사이즈보다 작을 때
- 마지막 페이지 일 때 (offset + 컨텐츠 사이즈를 더해서 전체 사이즈 구함)


### 최적화 예시
    // 위에 카운트 쿼리 생략을 자동으로 수행함
    return PageableExecutionUtils.getPage(content, pageable, () -> pageQuery.getCount());

-----------------------------------------------------------------------------------------------------------------------------------

> ## 스프링 데이터 페이징 활용 3 - 컨트롤러 개발

### 스프링 데이터 정렬
- 스프링 데이터 JPA는 자신의 정렬(Sort)을 Querydsl의 정렬(OrderSpecifier)로 편리하게 변경하는 기능을 제공한다


### 참고
- 정렬(Sort)는 조건이 조금만 복잡해져도 Pageable의 Sort 기능을 사용하기 어렵다
- 루트 엔티티 범위를 넘어가는 동적 정렬 기능이 필요하면 스프링 데이터 페이징이 제공하는 "Sort"를 사용하기 보다는 파라미터를 받아서 직접 처리











