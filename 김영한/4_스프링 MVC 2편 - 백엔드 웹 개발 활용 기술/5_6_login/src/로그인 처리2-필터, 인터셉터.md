
# 필터, 인터셉터.

------------------------------------------------------------------------------------------------------------------------------------------

> ## 서블릿 필터 소개.

### 공통 관심 사항.
- 로그인 하지 않은 사용자도 다음 URL을 직접 호출하면 상품 관리 화면에 들어갈 수 있다는 문제가 있다. 
- 모든 컨트롤러 로직에 공통으로 로그인 여부를 확인해야 한다.
- 이런 공통 관심사는 스프링의 AOP로도 해결할 수 있지만, 웹과 관련된 공통 관심사는 서블릿 필터 또는 스프링 인터셉터를 사용하는 것이 좋다.
- 웹과 관련된 공통 관심사를 처리할 대는 HTTP 헤더, URL의 정보들이 필요한데 서블릿 필터나 스프링 인터셉터는 "HttpServletRequest"를 제공


### 서블릿 필터 흐름.
    HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 컨트롤러.
- 모든 고객의 요청 로그를 남기는 요구사항이 있다면 필터를 사용하면 된다.
- 여기서 말하는 서블릿은 스프링의 디스패처 서블릿으로 생각하면 된다.


### 필터 제한.
    HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 컨트롤러 (로그인 사용자)
    HTTP 요청 -> WAS -> 필터(적절하지 않은 요청이라 판단, 서블릿 호출 X) (비 로그인 사용자)
- 필터에서 적절하지 않은 요청이라고 판단하면 거기에서 끝을 낼 수도 있다.


### 필터 체인.
    HTTP 요청 -> WAS -> 필터1 -> 필터2 -> ... -> 서블릿 -> 컨트롤러.
- 중간에 여러 개의 필터를 자유롭게 추가할 수 있다.


### 필터 인터페이스.
    public interface Filter {
        public default void init(FilterConfig filterConfig) throwws ServletException { }

        public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) ...;

        public default void destroy() { }
    }
- 필터 인터페이스를 구현하고 등록하면 서블릿 컨테이너가 필터를 싱글톤 객체로 생성하고, 관리한다.
  - init() : 필터 초기화 메서드, 서블릿 컨테이너가 생성될 때 호출된다.
  - doFilter() : 고객의 요청이 올 때 마다 해당 메서드가 호출된다. 필터의 로직을 구현하면 된다.
  - destroy() : 필터 종료 메서드, 서블릿 컨테이너가 종료될 때 호출된다.

------------------------------------------------------------------------------------------------------------------------------------------

> ## 서블릿 필터 - 요청 로그.

### Filter 사용하기.
- 필터를 사용하려면 Filter 인터페이스를 구현해야 한다.
- doFilter()
  - HTTP 요청이 오면 doFilter()가 실행된다.
- chain.doFilter()
  - 다음 필터가 있으면 필터를 호출하고, 필터가 없으면 서블릿을 호출한다.
  - 만약 이 로직을 호출하지 않으면 다음 단계로 진행되지 않는다.


### 필터를 등록하는 방법.
- "FilterRegistrationBean"을 사용해서 등록하면 된다.
  - setFilter() : 등록할 필터를 지정한다.
  - setOrder() : 여러 필터가 있을 때 순서가 낮을 수록 먼저 동작한다.
  - addUrlPatterns() : 필터를 적용할 URL 패턴을 지정한다. (한번에 여러 패턴을 지정할 수 있다)


### 참고.
- "@ServletComponentScan" "@WebFilter"로 필터 등록이 가능하지만 필터 순서 조절이 안된다.
- 실무에서 HTTP 요청시 같은 요청의 로그에 모두 같은 식별자를 자동으로 남기는 방법은 "logback mdc"로 검색하자.

------------------------------------------------------------------------------------------------------------------------------------------

> ## 서블릿 필터 - 인증 체크.

### 정리.
- 서블릿 필터를 잘 사용한 덕분에 로그인 하지 않은 사용자는 나머지 경로에 들어갈 수 없게 되었다.
- 공통 관심사를 서블릿 필터를 사용해서 해결한 덕분에 향후 로그인 관련 정책이 변경되어도 이 부분만 변경하면 된다.


### 참고.
- 필터에는 다음에 설명할 스프링 인터셉터는 제공하지 않는 아주 강력한 기능이 있다.
- chain.doFilter()를 호출해서 다음 필터 또는 서블릿을 호출할 때 request, response를 다른 객체로 바꿀 수 있다. (잘 사용하지 않음)

------------------------------------------------------------------------------------------------------------------------------------------

> ## 스프링 인터셉터 - 소개.

### 스프링 인터셉터.
- 서블릿 필터와 같이 웹과 관련된 공통 관심 사항을 효과적으로 해결할 수 있는 기술이다.
- 적용되는 순서와 범위, 그리고 사용방법이 다르다.


### 스프링 인터셉터 흐름.
    HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 인터셉터 -> 컨트롤러
- 디스패처 서블릿과 컨트롤러 사이에서 컨트롤러 호출 직전에 호출된다.
- 스프링 MVC의 시작점이 디스패처 서블릿이라고 생각하자.
- 스프링 인터셉터에도 URL 패턴을 적용할 수 있는데, 매우 정밀하게 설정할 수 있다.


### 스프링 인터셉터 제한.
    HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 스프링 인터셉터 -> 컨트롤러 (로그인 사용자)
    HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 스프링 인터셉터(적절하지 않은 요청이라 판단, 컨트롤러 호출X) (비 로그인 사용자)


### 스프링 인터셉터 체인.
    HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 인터셉터1 -> 인터셉터2 -> ... -> 컨트롤러.


### 스프링 인터셉터 인터페이스.
    public interface HandlerInterceptor {
      default boolean prehandl(HttpServletRequest request, HttpServletResponse response, Object hanlder) ... {} 

      default void postHandl(...) ... {}

      default void afterCompletion(...) ... { }

    }
- preHandle()
  - 컨트롤러 호출 전에 호출된다. (핸들러 어댑터 호출 전에 호출된다)
  - 응답값이 "true"이면 다음으로 진행하고, "false"이면 진행하지 않는다.
- postHandle()
  - 컨트롤러 호출 후에 호출된다. (핸들러 어댑터 호출 후에 호출된다)
  - 컨트롤러에서 예외가 발생하면 postHandle()은 호출되지 않는다.
- afterCompletion()
  - 뷰가 렌더링 된 이후에 호출된다.
  - 컨트롤러에서 예외가 발생하면 예외 정보 ex를 포함해서 호출된다. (예외가 발생하지 않으면 ex == null)


### 정리.
- 인터셉터는 스프링 MVC 구조에 특화된 필터 기능을 제공한다고 이해하면 된다.
- 특별히 필터를 꼭 사용해야 하는 상황이 아니라면 인터셉터를 사용하는 것이 더 편리하다.

------------------------------------------------------------------------------------------------------------------------------------------

> ## 스프링 인터셉터 - 요청 로그.

### HandlerMethod.
- 핸들러 정보는 어떤 핸들러 매핑을 사용하는가에 따라 달라진다.
- 일반적으로 @Controller, @RequestMapping을 활용한 핸들러 매핑을 사용하는데, 이 경우 핸들러 정보로 HandlerMethod가 넘어온다. 


### postHandler, afterCompletion.
- afterCompletion()은 예외를 받는다.


### 필터와 비교.
- addPathPatterns, excludePathPatterns로 매우 정밀하게 URL 패턴을 지정할 수 있다.


### PathPattern 공식문서
- https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/util/pattern/PathPattern.htm

------------------------------------------------------------------------------------------------------------------------------------------

> ## 스프링 인터셉터 - 인증 체크.

### 장점.
- 서블릿 필터와 비교해서 코드가 매우 간결하다.
- 인증이라는 것은 컨트롤러 호출 전에만 호출되면 된다.
- preHandler()만 구현하면 된다.


### URL 적용.
- addPathPatterns() : 인터셉터를 적용할 url.
- excludePathPatterns() : 인터셉터를 적용하지 않을 url.


### 정리.
- 특별한 문제가 없다면 인터셉터를 사용하는 것이 좋다.

------------------------------------------------------------------------------------------------------------------------------------------

> ## ArgumentResolver 활용.

### 어노테이션 설정.
- @Target : 어노테이션을 붙일 수 있는 장소 설정.
- @Retention : 어노테이션이 언제까지 살아 있을지 설정.


### HandlerMethodArgumentResolver.
- supportsParameter()
  - 로직을 실행하기 전에 조건을 확인하는 메서드.
- resolveArgument()
  - supportsParameter()가 true인 경우 실행되는 메서드.












