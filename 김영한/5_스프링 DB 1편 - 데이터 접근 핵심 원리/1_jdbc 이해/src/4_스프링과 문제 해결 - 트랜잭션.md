
 # 스프링과 문제 해결 - 트랜잭션.

----------------------------------------------------------------------------------------------------------------------------------

> ## 문제점들.

### 어플리케이션 구조.
- 프레젠테이션 계층 (Controller)
  - UI와 관련된 처리 담당
  - 웹 요청과 응답
  - 사용자 요청을 검증
  - 주 사용 기술 : 서블릿과 HTTP 같은 웹 기술, 스플이 MVC
- 서비스 계층
  - 비즈니스 로직을 담당
  - 주 사용 기술 : 가급적 특정 기술에 의존하지 않고, 순수 자바 코드로 작성
- 데이터 접근 계층
  - 실제 데이터베이스에 접근하는 코드
  - 주 사용 기술 : JDBC, JPA, File, Redis, Mongo, ...


### 순수한 서비스 계층.
- 여기서 가장 중요한 계층은 핵심 비즈니스 로직이 들어있는 서비스 계층이다.
- 서비스 계층.
  - 시간이 흘러서 UI, 데이터 저장 기술을 변경해도 비즈니스 롲기은 최대한 변경없이 유지되어야 한다.
  - 이렇게 하려면 서비스 계층을 특정 기술에 종속적이지 않게 개발해야 한다.
  - 서비스 계층이 특정 기술에 종속되지 않으면 비즈니스 로직을 유지보수 하기도 쉽고, 테스트 하기도 쉽다.


### 현재 코드의 문제점.
- 서비스 계층에서 트랜잭션을 사용하기 위해 DataSource, Connection, SQLException 같은 JDBC 기술에 의존해야 한다.
- 만약 JDBC -> JPA 같은 기술로 변경하려면 서비스 계층의 코드를 모두 변경해야 한다.


### JDBC 구현 기술이 서비스 계층에 누수되는 문제.
- 트랜잭션을 적용하기 위해 JDBC 구현 기술이 서비스 계층에 누수되었다.
- 서비스 계층은 순수해야 한다.
  - 구현 기술을 변경해도 서비스 계층 코드는 최대한 유지할 수 있어야 한다.
  - 데이터 접근 계층에 JDBC 코드를 다 몰아두는 것.
  - 물론 데이터 접근 계층의 구현 기술이 변경될 수도 있으니 데이터 접근 계층은 이넡페이스를 제공하는 것이 좋다.


### 트랜잭션 동기화 문제.
- 같은 트랜잭션을 유지하기 위해 커넥션을 파라미터로 넘겨야 한다.
- 똑같은 기능도 트랜잭션용 기능과 트랜잭션을 유지하지 않아도 되는 기능으로 분리해야 한다.


### 트랜잭션 적용 반복 문제.
- 트랜잭션 적용 코드를 보면 반복이 많다.
- 예 : try ... catch ... finally ...


### 예외 누수.
- 데이터 접근 계층의 JDBC 구현 기술 예외가 서비스 계층으로 전파된다.
- "SQLException" 체크 예외이기 때문에 데이터 접근 계층을 호출한 서비스 계층에서 해당 예외를 잡아서 처리하거나 밖으로 던져야한다.
- "SQLException"은 JDBC 전용 기술이기 때문에 데이터 접근 기술을 변경하면 서비스 계층에 코드 수정이 생긴다.


### JDBC 반복 문제.
- Connection, Statement, ResultSet 등의 비슷한 코드가 반복된다.


### 스프링과 문제 해결.
- 스프링은 서비스 계층을 순수하게 유지하면서 지금까지 이야기한 문제들을 해결할 수 있는 다양한 방법과 기술들을 제공한다.
- 스프링을 사용해서 우리 어플리케이션이 가진 문제들을 하나씩 해결해보자.

----------------------------------------------------------------------------------------------------------------------------------

> ## 트랜잭션 추상화.

### 구현 기술에 따른 트랜잭션 사용법.
- JDBC : con.setAutoCommit(false);
- JPA : transaction.begin();


### 트랜잭션 추상화.
- 이 문제를 해결하려면 트랜잭션 기능을 추상화하면 된다.
- 트랜잭션 추상화 인터페이스를 만들고 데이터 접근 기술에 따른 구현체를 만들어주면 된다.


### 스프링의 트랜잭션 추상화.
- 우리는 스프링이 제공하는 트랜잭션 추상화 기술을 사용하면 된다.
- 스프링에서는 데이터 접근 기술에 따른 트랜잭션 구현체도 대부분 만들어두어서 가져다 사용하기만 하면 된다.


### platformTransactionManager 인터페이스
- 스프링에서 제공하는 트랜잭션 매니저 인터페이스이다.

----------------------------------------------------------------------------------------------------------------------------------

> ## 트랜잭션 동기화.

### 스프링이 제공하는 트랜잭션 매니저 역할.
1. 트랜잭션 추상화
2. 리소스 동기화


### 리소스 동기화.
- 트랜잭션을 유지하려면 트랜잭션의 시작부터 끝까지 같은 데이터베이스 커넥션을 유지해야 한다.
- 파라미터로 커넥션은 전달하는 방법은 코드가 지저분해지고, 커넥션을 넘기는 메서드와 넘기지 않는 메서드를 중복해서 만들어야 하는 단점들이 있다.


### 트랜잭션 동기화 매니저.
- 쓰레드 로컬을 사용해서 커넥션을 동기화해준다.
- 트랜잭션 매니저는 내부에서 트랜잭션 동기화 매니저를 사용한다.
- 트랜잭션 동기화 매니저는 쓰레드 로컬을 사용하기 때문에 멀티쓰레드 상황에 안전하게 커넥션을 동기화할 수 있다.


### 동작 방식 설명.
1. 트랜잭션을 시작하려면 커넥션이 필요하다. 트랜잭션 매니저는 데이터소스를 통해 커넥션을 만들고 트랜잭션을 시작한다.
2. 트랜잭션 매니저는 트랜잭션이 시작된 커넥션을 트랜잭션 동기화 매니저에 보관한다.
3. 리포지토리는 트랜잭션 동기화 매니저에 보관된 커넥션을 꺼내서 사용한다. 따라서 파라미터로 커넥션을 전달하지 않아도 된다.
4. 트랜잭션이 종료되면 트랜잭션 매니저는 트랜잭션 동기화 매니저에 보관된 커넥션을 통해 트랜잭션을 종료하고, 커넥션도 닫는다.


### TransactionSynchronizationManager 클래스.
- org.springframework.transaction.support.


### 참고.
- 쓰레드 로컬을 사용하면 각각의 쓰레드마다 별도의 저장소가 부여된다.
- 따라서 해당 쓰레드만 해당 데이터에 접근할 수 있다.

----------------------------------------------------------------------------------------------------------------------------------

> ## 트랜잭션 문제 해결 - 트랜잭션 매니저1.

### DataSourceUtils.getConnection()
- 트랜잭션 동기화 매니저가 관리하는 커넥션이 있으면 해당 커넥션을 반환한다.
- 트랜잭션 동기화 매니저가 관리하는 커넥션이 없으면 새로운 커넥션을 생성해서 반환한다.


### DataSourceUtils.releaseConnection()
- 트랜잭션을 사용하기 위해 동기화된 커넥션은 커넥션을 닫지 않고 그대로 유지해준다.
- 트랜잭션 동기화 매니저가 관리하는 커넥션이 없는 경우 해당 커넥션을 닫는다.


### PlatformTransactionManger
- 트랜잭션 매니저를 주입 받는다.
- 구현체 : JDBC 트랜잭션 매니저, JPA 트랜잭션 매니저, ... 등


### 트랜잭션 매니저 커밋 롤백.
    transactionManager.commit(status)
    transactionManager.rollback(status)

----------------------------------------------------------------------------------------------------------------------------------

> ## 트랜잭션 문제 해결 - 트랜잭션 매니저2.

### 실행 순서.
1. 서비스 계층에서 getTransaction()을 호출해서 트랜잭션을 시작한다.
2. 트랜잭션을 시작하려면 먼저 데이터베이스 커넥션이 필요하다. 트랜잭션 매니저는 내부에 데이터소스를 사용해서 커넥션을 생성한다.
3. 커넥션을 수동 커밋 모드로 변경해서 실제 데이터베이스 트랜잭션을 시작한다.
4. 커넥션을 트랜잭션 동기화 매니저에 보관한다.
5. 트랜잭션 동기화 매니저는 쓰레드 로컬에 커넥션을 보관한다. 따라서 멀티 쓰레드 환경에 안전하게 커넥션을 보관할 수 있다.
6. 서비스는 비즈니스 로직을 실행하면서 리포지토리의 메서드를 호출한다.
7. 리포지토리 메서드들은 트랜잭션이 시작된 커넥션이 필요하다. DataSourceUtils.getConnection()
8. 획득한 커넥션을 사용해서 SQL을 데이터베이스에 전달해서 실행한다.
9. 비즈니스 로직이 끝나고 트랜잭션을 종료한다. (롤백, 커밋)
10. 트랜잭션을 종료하려면 동기화된 커넥션이 필요하다. 트랜잭션 동기화 매니저를 통해 동기화된 커넥션을 획득한다.
11. 획득한 커넥션을 통해 데이터베이스에 트랜잭션을 커밋하거나 롤백한다.
12. 전체 리소스를 정리한다.
    - setAutoCommit(true)로 되돌린다. (커넥션 풀 고려)
    - con.lse()를 호출해서 커넥션을 종료한다.


### 정리.
- 트랜잭션 추상화 덕분에 서비스 코드는 이제 JDBC 기술에 의존하지 않는다.
- 트랜잭션 동기화 매니저 덕분에 커넥션을 파라미터로넘기지 않아도 된다.

----------------------------------------------------------------------------------------------------------------------------------

> ## 트랜잭션 문제 해결 - 트랜잭션 템플릿.

### 개요.
- "try, catch, finally", 커밋, 롤백 등의 코드가 비즈니스 로직에서 계속 반복될 것이다.
- 이럴 때 템플릿 콜백 패턴을 활용하면 이런 반복 문제를 깔끔하게 해결할 수 있다.


### 참고.
- 템플릿 콜백 패턴에 대해서는 자세히 이해하지 못해도 괜찮다.
- "TransactionTemplate"이라는 편리한 기능을 적용하는구나 정도로 이해해도 된다.
- 템플릿 콜백 패턴에 대한 자세한 내용은 "스프링 핵심 원리 - 고급편" 강의를 참고하자.


### TransactionTemplate.
- execute() : 응답 값이 있을 때 사용한다.
- executeWithoutResult() : 응답 값이 없을 때 사용한다.


### 트랜잭션 템플릿 사용 로직.
- 트랜잭션 템플릿 덕분에 트랜잭션을 시작하고, 커밋하거나 롤백하는 코드가 모두 제거되었다.


### 트랜잭션 템플릿의 기본 동작.
1. 비즈니스 로직이 정상 수행되면 커밋한다.
2. 언체크 예외가 발생하면 롤백한다. (그 외의 경우에는 커밋)
   - 체크 예외의 경우 커밋한다.


### 정리.
- 트랜잭션 템플릿 덕분에 트랜잭션을 사용할 때 반복하는 코드를 제거할 수 있었다.
- 하지만 이곳은 서비스 로직인데 비즈니스 로직 뿐만 아니라 트랜잭션을 처리하는 기술 로직이 함께 포함되어 있다.
- 어플리케이션을 구성하는 로직을 핵심 기능과 부가 기능으로 구분하지만 서비스 입장에서 비즈니스 로직은 핵심 기능이고, 트랜잭션은 부가 기능이다.
- 서비스 로직은 가급적 핵심 비즈니스 로직만 있어야 한다.

----------------------------------------------------------------------------------------------------------------------------------

> ## 트랜잭션 문제 해결 - 트랜잭션 AOP 이해.

### 스프링이 제공하는 트랜잭션 AOP.
- 스프링이 제공하는 AOP 기능을 사용하면 프록시를 매우 편리하게 적용할 수 있다.
- 스프링은 트랜잭션 AOP를 편리하게 처리하기 위한 모든 기능을 제공한다.
- 스프링 부트를 사용하면 트랜잭션 AOP를 처리하기 위해 필요한 스프링 빈들도 자동으로 등록해준다.
- 개발자는 @Transactional 어노테이션만 붙여주면 된다.


### 참고.
- 스프링 AOP를 적용하려면 어드바이저, 포인트컷, 어드바이스가 필요하다.

----------------------------------------------------------------------------------------------------------------------------------

> ## 트랜잭션 문제 해결 - 트랜잭션 AOP 적용.

### 스프링 트랜잭션 AOP.
- 스프링이 제공하는 트랜잭션 AOP를 적용하기 위해 @Transactional 어노테이션을 붙인다.
- AOP를 적용하기 위해서는 DataSource, DataSourceTransactionManager를 빈으로 등록해야 한다.


### @Transactional.
- @Transactional은 클래스에 붙여도 되고 메서드에 붙여도 된다.
- 클래스에 붙이면 외부에서 호출 가능한 public 메서드가 AOP 적용 대상이 된다.


### @SpringBootTest
- 이 어노테이션이 있으면 테스트시 스프링 부트를 통해 스프링 컨테이너를 생성한다.
- 테스트에서 @Autowired 등을 통해 스프링 컨테이너가 관리하는 빈들을 사용할 수 있다.


### @TestConfiguration
- 테스트 안에서 내부 설정 클래스를 만들어서 사용하면서 이 어노테이션을 붙이면, 스프링 컨테이너에 빈들을 추가적으로 넣을 수 있다.


### 테스트에서 AOP 클래스인지 확인하는 방법.
    // AOP 클래스인지 확인 
    Assertions.assertThat(AopUtils.isAopProxy(확인할클래스)).isTrue();
    // AOP 클래스가 아닌지 확인
    Assertions.assertThat(AopUtils.isAopProxy(확인할클래스)).isfalse();

----------------------------------------------------------------------------------------------------------------------------------

> ## 트랜잭션 문제 해결 - 트랜잭션 AOP 정리.

### 트랜잭션 AOP 적용 전체 흐름.
1. AOP 트랜잭션이 걸려 있으면 프록시 호출
2. AOP 프록시에 트랜잭션 시작하기 위해 스프링 컨테이너에서 트랜잭션 매니저 획득 
3. transactionManager.getTransaction() 트랜잭션을 시작.
4. 데이터 소스 -> 커넥션 생성.
5. con.setAutoCommit(false)
6. 트랜잭션 동기화 매니저에 커넥션 보관
7. AOP 프록시에서 실제 서비스 호출.
8. 서비스에서 레포지토리를 사용하는 경우 트랜잭션 동기화를 통해 커넥션을 획득.


### 선언적 트랜잭션 관리 Declarative Transaction Management.
- @Transactional 어노테이션 하나만 선언해서 매우 편리하게 트랜잭션을 적용하는 것을 의미한다.
- 선언 트랜잭션 관리는 과거 XML에서 설정하기도 했다.
- 이름 그대로 해당 로직에 트랜잭션을 적용하겠다 라고 어딘가에 선언하기만 하면 트랜잭션이 적용되는 방식이다.


### 프로그래밍 방식의 트랜잭션 관리 programmatic transaction management.
- 트랜잭션 매니저 또는 트랜잭션 템플릿 등을 사용해서 트랜잭션 관련 코드를 직접 작성하는 것을 의미한다.


### 실무.
- 선언 트랜잭션 관리가 프로그래밍 방식에 비해서 훨씬 간편하고 실용적이기 때문에 실무에서는 대부분 선언적 트랜잭션 관리를 사용한다.
- 프로그래밍 방식의 트랜잭션 관리는 스프링 컨테이너나 스프링 AOP 기술 없이 간단히 사용할 수 있다.
- 프로그래밍 방식 트랜잭션 관리는 테스트 시에 가끔 사용될 때는 있다.


### 정리.
- 스프링이 제공하는 선언적 트랜잭션 관리 덕분에 드디어 트랜잭션 관련 코드를 순수한 비즈니스 로직에서 제거할 수 있었다.

----------------------------------------------------------------------------------------------------------------------------------

> ## 스프링 부트의 자동 리소스 등록.

### 개요.
- 스프링 부트 이전에는 데이터소스와 트랜잭션 매니저를 직접 스프링 빈으로 등록해야 했다.
- 그런데 스프링 부트가 나오면서 많은 부분이 자동화되었다. (스프링을 다루었다면 해당 부분을 주로 XML로 등록하고 관리했을 것이다)


### 데이터소스 - 자동 등록.
- 스프링 부트는 데이터소스(DataSource)를 스프링 빈에 자동으로 등록한다.
- 자동으로 등록되는 스프링 빈 이름 : dataSource.
- 참고로 개발자가 직접 데이터소스를 빈으로 등록하면 스프링 부트는 데이터소스를 자동으로 등록하지 않는다.


### 데이터소스 속성 등록.
    spring.datasource.url=/url경로
    spring.datasource.username=sa
    spring.datasource.password=
- 스프링 부트가 기본으로 생성하는 데이터소스는 커넥션풀을 제공하는 HikariDataSource이다
- 커넥션풀과 관련된 설정도 application.properties를 통해서 지정할 수 있다
- "spring.datasource.url" 속성이 없으면 내장 데이터베이스(메모리 DB)를 생성하려고 시도한다


### 트랜잭션 매니저 - 자동 등록.
- 스프링 부트는 "PlatformTransactionManager"를 자동으로 스프링 빈에 등록한다
- 자동으로 등록되는 빈 이름 : transactionManager
- 참고로 개발자가 직접 트랜잭션 매니저를 빈으로 등록하면 스프링 부트는 트랜잭션 매니저를 자동으로 등록하지 않는다


### 참고.
- 어떤 트랜잭션 매니저를 선택할지는 현재 등록된 라이브러리를 보고 판단한다.
- JDBC 기술을 사용하면 DataSourceTransactionManager를 빈으로 등록하고, JPA를 사용하면 JpaTransactionManager를 빈으로 등록한다.
- 둘 다 사용하는 경우 JpaTransactionManager를 등록한다.
  - JpaTransactionManager는 DataSourceTransactionManager가 제공하는 기능도 대부분 지원한다.
















