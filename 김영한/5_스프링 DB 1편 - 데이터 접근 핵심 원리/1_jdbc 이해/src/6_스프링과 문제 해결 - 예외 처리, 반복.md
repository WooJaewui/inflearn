
# 스프링과 문제 해결 - 예외 처리, 반복

---------------------------------------------------------------------------------------------------------------------------------------

> ## 체크 예외와 인터페이스

### 체크 예외와 인터페이스
- 서비스 계층은 가급적 특정 구현 기술에 의존하지 않고, 순수하게 유지하는 것이 좋다
- 서비스가 처리할 수 없는 Exception은 체크 예외를 런타임 예외로 전환해서 서비스 계층에 던지자


### 인터페이스 도입.
- 인터페이스를 도입하면 "MemberService"는 "MemberRepository"에만 의존하면 된다
- 이제 구현 기술을 변경하고 싶으면 DI를 사용해서 "MemberService" 코드의 변경 없이 구현 기술을 변경할 수 있다


### 체크 예외와 인터페이스.
- 인터페이스의 구현체가 체크 예외를 던지려면, 인터페이스 메서드에 먼저 체크 예외를 던지는 부분이 선언되어 있어야 한다
- 그래야 구현 클래스의 메서드도 체크 예외를 던질 수 있다
- 참고로 구현 클래스의 메서드에 선언할 수 있는 예외는 부모 타입에서 던진 예외와 같거나 하위 타입이어야 한다
  - 인터페이스 메서드에 "throws Exception"을 선언하면, 구현 클래스 메서드에 하위 Exception을 모두 사용할 수 있다


### 특정 기술에 종속되는 인터페이스.
- "SQLException"과 같은 특정 구현 기술에 종속적인 체크 예외를 사용하게 되면 인터페이스에도 해당 예외를 포함해야 한다
- 하지만 이것은 우리가 원하던 순수한 인터페이스가 아니다
- 향후 JDBC가 아닌 다른 기술로 변경한다면 인터페이스 자체를 변경해야 한다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 런타임 예외 적용

### 주의
- 예외를 변환할 떄는 기존 예외를 꼭 포함하자
- 장애가 발생하고 로그에서 진짜 원인이 나지 않는 심각한 문제가 발생할 수 있다


### 정리
- 체크 예외를 런타임 예외로 변환하면서 인터페이스와 서비스 계층의 순수성을 유지할 수 있게 되었다


### 남은 문제
- 리포지토리에서 넘어오는 특정한 예외의 경우 복구를 시도할 수도 있다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 데이터 겆ㅂ근 예외 직접 만들기

### 데이터 베이스 오류 코드
    e.getErrorCode()
- 에러 코드를 통해 데이터 베이스에서 발생하는 오류를 구분할 수 있다
- 같은 예외여도 데이터베이스마다 오류 코드는 다를 수 있다


### 정리
- SQL ErrorCode로 데이터베이스에 어떤 오류가 있는지 확인할 수 있다
- 예외 변환을 통해 SQLException을 특정 기술에 의존하지 않는 직접 만든 예외로 변환할 수 있다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 스프링 예외 추상화 이해

### 개요
- 스프링은 앞서 설명한 문제들을 해결하기 위해 데이터 접근과 관련된 예외를 추상화해준다


### 스프링 데이터 접근 예외 계층
- 스프링은 데이터 접근 계층에 대한 수십 가지 예외를 정리해서 일관된 예외 계층을 제공한다
- JDBC, JPA 등을 사용할 때 발생하는 예외를 스프링이 제공하는 예외로 변환해주는 역할도 스프링이 제공한다


### DataAccessException.
- DB 예외의 최고 상위는 "org.springframework.dao.DataAccessException"이다
- RuntimeException을 상속 받았다


### DataAccessException 종류
- Transient
  - 일시적이라는 뜻이다
  - Transient 하위 예외는 동일한 SQL을 다시 시도했을 때 성골할 가능성이 있다
  - 예 : 쿼리 타임아웃, 락과 관련된 오류들이다
- NonTransient
  - 일시적이지 않다는 뜻이다
  - 같은 SQL을 그대로 반복해서 실행하면 실패한다
  - 예 : 데이터 오류, 데이터베이스 제약 조건 위해 등이 있다


### 스프링이 제공하는 예외 변환기
- 스프링은 데이터베이스에서 발생하는 오류 코드를 스프링이 정의한 예외로 자동으로 변환해주는 변환기를 제공한다


### 참고
- DB마다 SQL ErrorCode는 다르다
- 그런데 스프링은 어떻게 SQL ErrorCode를 읽어서 예외를 변환할까?
- org.springframework.jdbc.support.sql-error-codes.xml 파일 안에 error 코드를 다 정의해 놨다


### 정리
- 스프링은 예외 변환기를 통해서 SQLException의 ErrorCode에 맞는 적절한 스프링 데이터 접근 예외로 변환해준다
- 스프링 예외 추상화 덕분에 특정 기술에 종속적이지 않게 되었다
- 물론 스프링이 제공하는 예외를 사용하기 때문에 스프링에 대한 기술 종속성은 발생한다
  - 스프링에 대한 기술 종속성까지 완전히 제거하려면 예외를 모두 직접 정의하고 예외 변환도 직접 하면 된다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 스프링 예외 추상화 적용

### 정리
- 스프링이 예외를 추상화해준 덕분에, 서비스 계층은 특정 리포지토리의 구현 기술과 예외에 종속적이지 않게 되었다
- 따라서 서비스 계층은 특정 구현 기술이 변경되어도 그대로 유지할 수 있다

---------------------------------------------------------------------------------------------------------------------------------------

> ## JDBC 반복 문제 해결 - JdbcTemplate

### 개요
- 스프링은 JDBC의 반복 문제를 해결하기 위해 JdbcTemplate이라는 템플릿을 제공한다


### 정리
- JdbcTemplate은 JDBC로 개발할 때 발생하는 반복을 대부분 해결해준다
- JdbcTemplate이 트랜잭션을 위한 커넥션 동기화, 예외 처리 등의 기능을 모두 처리해준다


### 참고
- 템플릿 콜백 패턴은 스프링 핵심 원리 - 고급편을 참고





















