
# 데이터 접근 기술 - 시작

---------------------------------------------------------------------------------------------------------------------------------

> ## 데이터 접근 기술 진행 방식 소개.

### SQL Mapper 주요 기능
- 개발자는 SQL만 작성하면 해당 SQL의 결과를 객체로 편리하게 매핑해준다
- JDBC를 직접 사용할 때 발생하는 여러가지 중복을 제거해주고, 기타 개발자에게 여러가지 편리한 기능을 제공한다


### ORM 주요 기능
- JDBCTemplate, Mybatis 같은 SQL 매퍼 기술은 SQL을 개발자가 직접 작성해야 하지만, JPA를 사용하면 기본적인 SQL은 JPA가 작성하고 처리.
  - JPA : 자바 진형 ORM의 표준
  - Hibernate : JPA에서 가장 많이 사용하는 구현체
  - 자바에서 ORM을 사용할 경우 JPA 인터페이스, 하이버네이트 구현체를 사용한다


### 강의 순서
- 데이터 접근 기술에 대한 기본 이해와 전체 큰 그림을 그린다
- 각 기술들의 핵심 기능 위주로 학습한다
- 각 기술들을 점진적으로 도입하는 과정을 통해서 각 기술의 특징과 장단점을 자연스럽게 이해할 수 있다

---------------------------------------------------------------------------------------------------------------------------------

> ## 프로젝트 구조 설명1 - 기본

### DTO Data Transfer Object
- 데이터 전송 객체
- DTO는 기능은 없고 데이터를 전달만 하는 용도로 사용되는 객체를 뜻한다
  - 객체의 주 목적이 데이터를 전송하는 것이라면 DTO라 할 수 있다
- 참고로 이런 규칙은 정해진 것이 없기 때문에 해당 프로젝트 안에서 일관성 있게 규칙을 정하면 된다


### DTO를 어떤 패키지에 둘 것인가?
- DTO를 제공하는 마지막이 언제인지 확인


---------------------------------------------------------------------------------------------------------------------------------

> ## 프로젝트 구조 설명2 - 설정

### @EventListener(ApplicationReadyEvent.class)
- 스프링 컨테이너가 완전히 초기화를 다 끝내고, 실행 주니가 되었을 때 발생하는 이벤트
- 스프링이 이 시점에 해당 어노테이션이 붙은 initData() 메서드를 호출해준다
  - 참고로 이 기능 대신 @PostConstruct를 사용할 수 경우 AOP 같은 부분이 다 처리되지 않은 시점에 호출될 수 있기 때문에 문제가 발생할 수 있다
  - 예를 들어 @Transactional과 관련된 AOP가 적용되지 않은 상태로 호출될 수 있다


### Application
- @Import(MemoryConfig.class)
  - 앞서 설정한 MemoryConfig를 설정 파일로 사용한다
- @Profile("local")
  - 특정 프로필의 경우메나 해당 스프링 빈을 등록한다
  - 여기서는 local이라는 이름의 프로필이 사용되는 경우에만 TestDataInit을 등록한다 


### 프로필
- 스프링은 로딩 시점에 application.properties의 spring.profiles.active 속성을 읽어서 프로필로 사용한다
- 예를 들어서 로컬 PC에서는 로컬 PC 데이터베이스에 접근해야 하고, 운영 환경에서는 운영 DB에 접근해야 되는 경우 프로필을 사용한다


### main 프로필
    //properties
    spring.profiles.active=local
- /src/main/resources 하위의 application.properties 
- 설정하지 않으면 자동으로 "default"로 등록된다


### test 프로필
    //properties
    spring.profiles.active=test
- 테스트 프로필에서는 일부로 초기화 데이터를 등록하지 않았다
- 초기화 데이터 덕분에 편리한 점도 있지만, 테스트 케이스를 실행할 때는 문제가 될 수 있다
- 프로필 기능 덕분에 테스트 케이스에서는 test 

---------------------------------------------------------------------------------------------------------------------------------

> ## 프로젝트 구조 설명3 - 테스트

### @AfterEach
- 테스트는 서로 영향을 주면 안된다
- 각각의 테스트의 실행이 끝나는 시점에 호출된다
- 여기서는 메모리 저장소를 완전히 삭제해서 다음 테스트에 영향을 주지 않도록 초기화한다


### containsExactly
    Assetions.assertThat(result).containsExactly(items);
- 순서와 값 모두 같아야만 true가 된다


### 인터페이스를 테스트하자
- 인터페이스를 테스트하는 것이 향후 다른 구현체로 변경되었을 때 해당 구현체가 잘 동작하는지 같은 테스트로 편리하게 검증할 수 있다

---------------------------------------------------------------------------------------------------------------------------------

> ## 데이터베이스 테이블 생성

### 테이블 생성
    drop table if exists item CASCADE;
    create table item
    (
      id bigint generated by default as identity,
      item_name varchar(10),
      price integer,
      quantity integer,
      primary key (id)
    );
- generated by default as identity
  - 시퀀스같은 역할을 한다


### 참고 - 테이터베이스 기본 키 조건
- NULL 값은 허용하지 않는다
- 유일해야 한다
- 변해선 안 된다


### 테이블의 기본 키를 선택하는 전략은 크게 2가지가 있다
- 자연 키 natural key
  - 비즈니스에 의미가 있는 키
  - 예 : 주민등록번호, 이메일, 전화번호
- 대리 키 surrogate key
  - 비즈니스와 관련 없는 임의로 만들어진 키, 대체 키로도 불린다
  - 예 : 오라클 시퀀스, auto_increment, identity, 키생성 테이블 사용


### 참고 
- 자연키보다는 대리 키를 권장한다
- 비즈니스 환경은 언젠가 변한다
  - 주민등록번호를 PK로 사용했는데 정부 정책이 변경되면서 주민등록번호를 저장할 수 없게 변경되면서 데이터베이스를 엄청난 변화를 하게 되었다
- 주민등록번호, 이메일처럼 자연 키의 후보가 되는 컬럼들은 필요에 따라 유니크 인덱스를 설정해서 사용하는 것을 권장
















