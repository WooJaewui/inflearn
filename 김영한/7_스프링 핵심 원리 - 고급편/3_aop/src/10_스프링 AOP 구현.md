
# 스프링 AOP 구현

----------------------------------------------------------------------------------------------------------------------------------

> ## 스프링 AOP 구현 1 - 시작

### @Around
    @Around("execution(* 패키지..메서드명(파라미터))")


### 참고
- 스프링 AOP는 AspectJ의 문법을 차용하고, 프록시 방식의 AOP를 제공한다 (AspectJ를 직접 사용하지 않는다)
- aspectjweaver.jar
  - AspectJ 언어를 사용하여 자바에서 AOP를 사용하는 방법 (AspectJ 인터페이스, 언어 등을 사용)
  - 실제 AspectJ가 제공하는 컴파일, 로드타임 위버 등을 사용하는 것은 아니다

----------------------------------------------------------------------------------------------------------------------------------

> ## 스프링 AOP 구현 2 - 포인트컷 분리

### @PointCut
- 시그니처
  - 메서드 이름과 파라미터를 합친 것
- 메서드의 반환 타입은 void여야 한다
- 코드 내용은 비워둔다
- 포인트 시그니처를 만들어 놓고 여러 어드바이스에서 사용할 수 있다 (외부 어드바이스에서 사용 가능)

----------------------------------------------------------------------------------------------------------------------------------

> ## 스프링 AOP 구현 3 - 어드바이스 추가

### 여러 포인트컷 사용
    @Around("allOrder() && allService()")
    public Object 메서드이름(ProceedingJoinPoint joinPoint) {
      ...
    }

----------------------------------------------------------------------------------------------------------------------------------

> ## 스프링 AOP 구현 4 - 포인트 컷 참조

### 포인트 컷 클래스 만들기
    public class Pointcuts {
      @Pointcut(..)
      ...
      ...
    }

    @Aspect
    public class Aop {
      @Around(패키지이름.Pointcuts.메서드이름())
      ...
    }

----------------------------------------------------------------------------------------------------------------------------------

> ## 스프링 AOP 구현 5 - 어드바이스 순서

### @Order
- @Aspect 클래스 단위로 순서를 결정할 수 있다
- 내부 클래스로 만들거나, Aop 마다 클래스르 만들어야 한다

----------------------------------------------------------------------------------------------------------------------------------

> ## 스프링 AOP 구현 6 - 어드바이스 종류

### 어드바이스 종류
- @Around : 메서드호출 전후에 수행, 가장 강력한 어드바이스, 조인 포인트 실행 여부 선택, 반환값 변환, 예외 변환 등이 가능
- @Before : 조인 포인트 실행 이전에 실행
- @After Returning : 조인 포인트가 정상 완료 후 실행
- @After Throwing : 메서드가 예외를 던지는 경우 실행
- @After : 조인 포인트가 정상 또는 예외에 관계없이 실행


### 참고 정보 획득
- 모든 어드바이스는 JoinPoint를 첫번째 파라미터에 사용할 수 있다 (생략 가능)
- @Around는 ProceedingJoinPoint를 무조건 파라미터로 선언하고 사용해야 한다
- ProceedingJoinPoint는 JoinPoint의 하위 타입이다


### @Before
- 작업 흐름을 변경할 수는 없다
- 메서드 종료시 자동으로 다음 타켓이 호출된다 (예외가 발생하면 다음 코드가 호출되지는 않는다)


### @AfterReturning
- returning 속성에 사용된 이름은 어드바이스 메서드의 매개변수 이름과 일치해야 한다
- returning 절에 지정된 타입의 값을 반환하는 메서드만 대상으로 실행한다
- 반환되는 객체를 변경할 수는 없다


### @AfterThrowing
- throwing 속성에 사용된 이름은 어드바이스 메서드의 매개변수 이름과 일치해야 한다
- throwing 절에 지정된 타입과 ㅁ자은 예외를 대상으로 실행한다 (부모 타입을 지정하면 모든 자식 타입은 인정된다)


### @Around
- 메서드의 실행 전후에 작업을 수행한다
- 가장 강력한 어드바이스
  - 조인 포인트 실행 여부 선택 - joinPoint.proceed();
  - 전달 값 변환 - joinPoint.proceed(args);
  - 반환 값 변환
  - 예외 변환
  - 트랜잭션 처럼 try ~ catch 문을 사용할 수 있음
- 어드바이스의 첫 번째 파라미터는 ProceedingJoinPoint를 사용해야 한다
- proceed()를 여러번 실행할 수 있다


### @Around 외에 다른 어드바이스가 존재하는 이유
- @Around가 가장 넓은 기능을 제공하는 것은 맞지만, 실수할 가능성이 있다 (메서드를 호출하지 않는 경우)
- @Before, @After 같은 어드바이스는 기능은 적지만 실수할 가능성이 낮고, 코드도 단순하다


### 좋은 설계는 제약이 있는 것이다
- 제약 덕분에 역할이 명호가해진다
- 다른 개발자도 이 코드를 보고 고민해야 하는 범위가 줄어들고 코드의 의도도 파악하기 쉽다

















