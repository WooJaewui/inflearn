
# 스프링 AOP - 실무 주의사항

----------------------------------------------------------------------------------------------------------------------------------

> ## 프록시와 내부 호출 문제

### 스프링 AOP
- AOP를 적용하면 스프링은 대상 객체 대신에 프록시를 스프링 빈으로 등록한다
- 프록시 객체가 주입되기 때문에 대상 객체를 직접 호출하는 문제는 일반적으로 발생하지 않는다
- 대상 객체의 내부에서 메서드 호출이 발생하면 프록시를 거치지 않고 대상 객체를 직접 호출하는 문제가 발생한다


### 자바 메서드 특징
- 메서드 앞에 별도의 참조가 없으면(클래스 명) this 라는 뜻으로 자신의 인스턴스를 가리킨다
- 결과적으로 자기 자신의 내부 메서드를 호출하는 this.internal()이 된다


### 프록시 방식의 한계
- 스프링은 프록시 방식의 AOP를 사용한다


### 참고
- 실제 코드에 AOP를 직접 적용하는 AspectJ를 사용하면 이런 문제가 발생하지 않는다
- 또한, 스프링 컨테이너도 사용하지 않아도 된다
- 하지만 로드 타임 위빙 등을 사용해야 하는데, 설정이 복잡하고 JVM 옵션을 주어야 하는 부담이 있다

----------------------------------------------------------------------------------------------------------------------------------

> ## 프록시와 내부 호출 - 대안1 자기 자신 주입

### 순환 참고 문제
    spring.main.allow-circular-references=true (applciation.properties)
- 스프링 부트 2.6부터 순환 참조를 기본적으로 금지


### 해결
- internal()을 호출할 때 자기 자신의 인스턴스를 호출하는 것이 아니라 프록시 인스턴스를 통해서 호출

----------------------------------------------------------------------------------------------------------------------------------

> ## 프록시와 내부 호출 - 대안2 지연 조회

### 지연 조회 
    1. ApplicationContext를 주입 받기
    2. ObjectProvider
- 스프링 컨테이너에서 빈을 조회해서 사용하는 방식
- ApplicationContext는 너무 많은 기능을 제공해서, 빈만 조회하는 경우 ObjectProvider를 통해 객체를 조회하자

----------------------------------------------------------------------------------------------------------------------------------

> ## 프록시와 내부 호출 - 대안3 구조 변경

### 참고
- AOP는 주로 트랜잭션 적용이나 주요 컴포넌트의 로그 출력 기능에 사용된다
- AOP는 public 메서드에만 적용한다
- public 메서드에서 public 메서드를 내부 호출하는 경우에는 문제가 발생한다
- AOP가 잘 적용되지 않으면 내부 호출 문제를 확인하자

----------------------------------------------------------------------------------------------------------------------------------

> ## 프록시 기술과 한계 - 타입 캐스팅

### 정리
- proxyTargetClass=false : JDK 동적 프록시를 사용해서 인터페이스 기반 프록시 생성
- proxyTargetClass=true : CGLIB를 사용해서 구체 클래스 기반 프록시 생성
- 참고로 옵션과 무관하게 인터페이스가 없으면 JDK 동적 프록시를 적용할 수 없으므로 CGLIB를 사용한다

----------------------------------------------------------------------------------------------------------------------------------

> ## 프록시 기술과 한계 - 의존관계 주입

### JDK 동적 프록시에 구체 클래스 타입 주입
- JDK 동적 프록시를 사용하면 주입할 때 인터페이스만 사용해야 한다(구체 클래스 사용시 UnsatisfiedDependencyException 발생)
- DI 장점을 생각하면 인터페이스가 있을 땐 항상 인터페이스를 통한 DI를 하는 것이 좋다

----------------------------------------------------------------------------------------------------------------------------------

> ## 프록시 기술과 한계 - CGLIB

### CGLIB
- 구체 클래스를 상속 받아서 프록시를 만드는 방식


### CGLIB 구체 클래스 기반 프록시 문제점
- 대상 클래스에 기본 생성자 필수
- 생성자 2번 호출 문제
- final 키워드 클래스, final 메서드 사용 불가


### 대상 클래스에 기본 생성자 필수
- 상속을 받으면 자식 클래스의 생성자를 호출할 때 자식 클래스의 생성자에서 부모 클래스의 생성자도 호출해야 한다
- 부모 클래스의 생성자도 호출해야 한다


### 생성자 2번 호출 문제
    1. 실제 target의 객체를 생성할 때
    2. 프록시 객체를 생성할 때 부모 클래스의 생성자 호출
- CGLIB는 구체 클래스를 상속 받는다
- 자바 언어에서 상속을 받으면 자식 클래스의 생성자를 호출할 때 부모 클래스의 생성자도 호출해야 한다


### final 클래스, final 메서드 사용 불가
- 프레임워크 같은 개발이 아니라 일반적인 웹 어플리케이션을 개발할 때는 final 키워드를 잘 사용하지 않는다
- 따라서 이 부분이 특별히 문제가 되지는 않는다

----------------------------------------------------------------------------------------------------------------------------------

> ## 프록시 기술과 한계 - 스프링의 해결책

### 스프링 3.2, CGLIB를 스프링 내부에 함께 패키징
- CGLIB를 사용하려면 CGLIB 라이브러리가 별도로 필요했다
- 스프링은 CGLIB 라이브러리를 스플이 내부에 함께 패키징해서 별도의 라이브러리 추가 없이 CGLIB를 사용할 수 있게 되었따


### CGLIB 기본 생성자 필수 문제 해결
- 스프링 4.0부터 CGLIB의 기본 생성자가 필수인 문제가 해결되었다
- "objenesis"라는 특별한 라이브러리를 사용해서 기본 생성자 없이 객체 생성이 가능하다
- 참고로 이 라이브러리는 생성자 호출 없이 객체를 생성할 수 있게 해준다


### 스프링 부트 2.0 - CGLIB 기본 사용
- 스프링 부트 2.0 버전부터 CGLIB를 기본으로 사용하도록 했다
- 이렇게 해서 구체 클래스 타입으로 의존관계를 주입하는 문제를 해결했다
- 스프링 부트는 별도의 설정이 없다면 AOP를 적용할 때 기본적으로 "proxyTargetClass=true"로 설정해서 사용한다
- 따라서 인터페이스가 있어도 JDK 동적 프록시를 사용하는 것이 아니라 항상 CGLIB를 사용해서 구체클래스를 기반으로 프록시를 생성한다


### 정리
- 스프링은 최종적으로 스프링 부트 2.0에서 CGLIB를 기본으로 사용하도록 결정했다
- CGLIB를 사용하면 JDK 동적 프록시에서 동작하지 않는 구체 클래스 주입이 가능하다
- 여기서 추가로 CGLIB의 단점들이 이제는 많이 해결되었다
- final 클래스, final 메서드는 큰 문제가 되지 않는다

















