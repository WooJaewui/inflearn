
# 영속성 관리 - 내부 동작 방식

----------------------------------------------------------------------------------------------------------------------------------

> ## 영속성 컨텍스트 1

### JPA에서 가장 중요한 2가지
1. 객체와 관계형 데이터베이스 매핑하기 (Object Relational Mapping)
2. 영속성 컨텍스트


### 영속성 컨텍스트
- 엔티티를 영구 저장하는 환경이라는 뜻 (의역)
- 영속성 컨텍스트는 논리적인 개념 (눈에 보이지 않음)
- 엔티티 매니저를 통해서 영속성 컨텍스트에 접근


### 엔티티의 생명주기
- 비영속 (new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
- 영속 (managed) : 영속성 컨텍스트에 관리되는 상태 (persist())
- 준영속 (detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태 (detach())
- 삭제 (removed) : 삭제된 상태 (remove())


### 영속성 컨텍스트의 이점
- 1차 캐시
- 동일성 (identity) 보장
- 트랜잭션을 지원하는 쓰기 지연 (transactional write-behind)
- 변경 감지 (Dirty Checking)
- 지연 로딩 (Lazy Loading)

----------------------------------------------------------------------------------------------------------------------------------

> ## 연속성 컨텍스트 2

### 1차 캐시
- 같은 트랜잭션 내에서 캐싱을 할 수 있다
- 1차 캐시는 성능에 큰 이득을 보이진 않는다


### 영속 엔티티의 동일성 보장
- 1차 캐시로 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 어플리케이션 차원에서 제공


### 쓰기 지연
- transaction.commit() 하는 순간에 INSERT SQL을 보낸다 
- 영속 컨텍스트에 쓰기 지연 SQL 저장소에 SQL을 쌓아두고 transaction.commit()할 때 flush() 한다


### 엔티티 주의 사항
- Entity는 내부적으로 리플렉션을 사용하기 때문에 기본 생성자를 꼭 만들어줘야 한다


### 변경 감지 Dirty Checking
- 스냅샷 : 맨 처음 1차 캐시에 저장한 데이터
- Entity : Entity에 setter 메서드 등을 통해 값이 변경된 데이터
- 스냅샷과 Entity의 값을 비교해서 변경되었다면 transaction.commit() 시점에 UPDATE 쿼리를 만들어줌

----------------------------------------------------------------------------------------------------------------------------------

> ## 플러시

### 플러시
- 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영
- 변경 감지
- 수정된 엔티티 쓰기 지연 SQL 저장소 등록
- 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송 (등록, 수정, 삭제 쿼리)


### 영속성 컨텍스트를 플러시하는 방법
- 직접 호출 : entityManager.flush()
- 플러시 자동 호출 : transaction.commit()
- 플러시 자동 호출 : JPQL 쿼리 실행 (뒤에 나옴)


### JPQL 쿼리 실행시 플러시가 자동으로 호출되는 이유
- 자동 플러시가 되지 않으면 1차 캐시에 저장된 INSERT 데이터가 DB 저장되지 않았기 때문에 JPQL 조회로 조회되지 않을 수 있다


### 플러시 모드 옵션
- FlushModeType.AUTO : 커밋이나 쿼리를 실행할 때 플러시 (기본값 - 특별한 이유가 없으면 변경 X)
- FlushModeType.COMMIT : 커밋할 때만 플러시


### 플러시 주의 사항
- 1차 캐시가 지워지지 않음
- 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화
- 트랜잭션이라는 작업 단위가 중요 -> 커밋 직전에만 동기화 하면 됨

----------------------------------------------------------------------------------------------------------------------------------

> ## 준영속 상태

### 준영속 상태
- 영속 상태의 엔티티가 영속성 컨텍스트에서 분리 (detached)
- 영속성 컨텍스트가 제공하는 기능을 사용 못함


### 준영속 상태로 만드는 방법
- entityManager.detach(entity) : 특정 엔티티만 준영속 상태로 전환
- entityManager.clear() : 영속성 컨텍스트를 완전 초기화
- entityManager.close() : 영속성 컨텍스트를 종료

----------------------------------------------------------------------------------------------------------------------------------

### 정리

### 영속성 컨텍스트, 엔티티 매니저
- 엔티티 매니저와 영속성 컨텍스트가 N:1


### 엔티티의 생명주기
- 비영속 (1차 캐시에 아직 넣지 않음)
- 영속 (1차 캐시 존재)
- 준영속 (1차 캐시에서 삭제)
- 삭제 (DB에서 삭제)


### 영속성 컨텍스트의 이점
- 1차 캐시
- 동일성(identity) 보장
- 트랜잭션을 지원하는 쓰기 지연 (transactional write-behind)
- 변경 감지 (Dirty Checking)
- 지연 로딩 (Lazy Loading)









