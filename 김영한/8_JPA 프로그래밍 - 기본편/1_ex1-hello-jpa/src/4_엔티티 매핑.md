
# 엔티티 매핑

----------------------------------------------------------------------------------------------------------------------------------

> ## 객체와 테이블 매핑

### 엔티티 매핑 소개
- @Entity, @Table : 객체와 테이블 매핑
- @Column : 필드와 컬럼 매핑
- @Id : 기본 키 매핑
- @ManyToOne, @JoinColumn : 연관관계 매핑


### @Entity
- @Entity가 붙은 클래스는 JPA가 관리하는 엔티티라 한다
- JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 필수
- 속성 name
  - JPA에서 사용할 엔티티 이름을 지정한다
  - 기본값 : 클래스 이름을 그대로 사용 (예 : Member)
  - 같은 클래스 이름이 없으면 가급적 기본값을 사용한다 


### 주의
- 기본 생성자 필수 (파라미터가 없는 public 또는 protected 생성자)
- final 클래스, enum, interface, inner 클래스 사용 X
- 저장할 필드에 final 사용 X


### @Table
    @Table(name = "MBR")
- 엔티티와 매핑할 테이블 지정 (엔티티 클래스 위에 사용)
- 속성
  - name : 매핑할 테이블 이름
  - catalog : 데이터베이스 catalog 매핑
  - schema : 데이터베이스 schema 매핑
  - uniqueConstraints(DDL) : DDL 생성 시에 유니크 제약 조건 생성

----------------------------------------------------------------------------------------------------------------------------------

> ## 데이터베이스 스키마 자동 생성

### 데이터베이스 스키마 자동 생성
- DDL을 어플리케이션 실행 지점에 자동 생성
- 테이블 중심 -> 객체 중심
- 데이터베이스 방언을 활용해서 데이터베이스에 맞는 적절한 DDL 생성
- 이렇게 생성된 DDL은 개발 장비에서만 사용
- 생성된 DDL은 운영서버에서는 사용하지 않거나, 적절히 다듬은 후 사용


### hibernate.hbm2ddl.auto
    // persistence.xml
    hibernate.hbm2ddl.auto=create
- create : 기존테이블 삭제 후 다시 생성 (DROP + CREATE)
- create-drop : create와 같으나 종료시점에 테이블 DROP (DROP + CREATE + DROP)
- update : 변경된 컬럼만 반영 - 컬럼 추가만 반영(운영 DB에는 사용하면 안됨)
- validate : 엔티티와 테이블이 정상 매핑되었는지만 확ㅇ니
- none : 사용하지 않음


### 데이터베이스 스키마 자동 생성 - 주의
- 운영 장비에는 절대 create, create-drop, update 사용하면 안된다
- 개발 초기 단계는 create 또는 update
- 테스트 서버는 update 또는 validate
- 스테이징과 운영 서버는 validate 또는 none


### DDL 생성 기능
    @Column(name = "컬럼이름", length = 10, unique = true, ...)
- 제약조건 추가
- DDL 생성 기능은 DDL 자동 생성할 때만 사용되고 JPA 실행 로직에는 영향을 주지 않는다

----------------------------------------------------------------------------------------------------------------------------------

> ## 필드와 컬럼 매핑

### @Enumerated
- 엔티티에 enum을 사용해야 되는 경우에 사용한다


### @Temporal
- TemporalType enum 클래스
  - DATE
  - TIME
  - TIMESTAMP


### @LOB
- varchar 범위를 넘는 데이터를 사용하고 싶은 경우에 사용한다


### 어노테이션 정리
- @Column : 컬럼 매핑
  - name : 필드와 매핑할 테이블의 컬럼 이름 (기본값 : 객체의 필드 이름)
  - insertable, updatable : 등록, 변경 가능 여부 (기본값 : true)
  - nullable(DDL) : null 값의 허용 여부를 설정한다, false로 설정하면 DDL 생성 시에 not null 제약조건이 붙는다
  - unique(DDL) : @Table의 uniqueConstraints와 같지만 한 컬럼에 간단히 유니크 제약 조건을 걸 때 사용한다 (운영에서 사용 X)
- @Enumerated : enum 클래스 매핑 
  - value
    - EnumType.ORDINAL : enum 순서를 데이터베이스에 저장
    - EnumType.STRING : enum 이름을 데이터베이스에 저장
- @Temporal : 날짜 타입 매핑 
  - value
    - TemporalType.DATE : 날짜 (예 : 2013-10-11)
    - TemporalType.TIME : 시간 (예 : 11:11:11)
    - TemporalType.TIMESTAMP : 날짜와 시간 (예 : 2013-10-11 11:11:11)
- @Lob : BLOB, CLOB 매핑
  - 지정할 수 있는 속성이 없다
  - 매핑하는 필드 타입이 문자면 CLOB 매핑, 나머지는 BLOB 매핑
    - CLOB Character Large Object: String, char[], java.sql.CLOB
    - BLOB Binary Large Object : byte[], java.sql.BLOB
- @Transient : 특정 필드를 컬럼에 추가하지 않음
  - 필드 매핑 X

----------------------------------------------------------------------------------------------------------------------------------

> ## 기본 키 매핑

### 기본 키 매핑 어노테이션
- @Id 


### 기본 키 매핑 방법
- 직접 할당 : @Id
- 자동 생성 : @GeneratedValue
  - IDENTITY : 데이터베이스에 위임, MySQL
  - SEQUENCE : 데이터베이스 시퀀스 오브젝트 사용, Oracle
    - @SequenceGenerator 필요
  - TABLE : 키 생성용 테입르 사용, 모든 DB에서 사용
    - @TableGenerator 필요
  - AUTO : 방언에 따라 자동 지정, 기본값


### AUTO
    @GenerateValue(Strategy = GenerationType.AUTO)
- 방언에 따라 자동으로 값을 지정
- Oracle : sequence, MySQL : AUTO_INCREMENT, ...


### SEQUENCE
    @GenerateValue(strategy = GenerationType.SEQUENCE, generator = "시퀀스이름")
    @SequenceGeneretor(name = "시퀀스 이름", allocationSize = "50", ... ) 
- 시퀀스를 사용하는 경우에 지정
- @SequenceGenerator
  - name : generator 이름
  - sequenceName : DB에 등록되어 있는 식별자 이름
  - initialValue : DDL 생성시에만 사용됨, 시퀀스 초기값을 설정
  - allocationSize : 시퀀스 한 번 호출에 증가하는 수 (기본값 : 50)
  - catalog, schema : 데이터베이스 catalog, schema 이름


### TABLE
- 키 생성 전용 테이블을 하나 만들어서 데이터베이스 시퀀스를 흉내내는 전략
- 장점 : 모든 데이터베이스에 적용 가능
- 단점 : 성능
- @TableGenerator
  - name : generator 이름
  - table : 키 생성 테이블 명
  - pkColumnName : 시퀀스 컬럼명
  - valueColumnName : 시퀀스 값 컬러명
  - initialValue : 초기 값
  - allocationSize : 시퀀스 한 번 호출에 증가하는 수 (기본값 : 50)
  - catalog, schema : 데이터베이스 catalog, schema 이름
  - uniqueConstraints : 유니크 제약 조건


### IDENTITY
- 기본 키 생성을 데이터베이스에 위임
- 주로 MySQL, PostgreSQL, SQL Server, DB2 에서 사용 (예 : MySQL AUTO_INCREMENT)
- IDENTITY 전략은 persist() 시점에 즉시 INSERT 쿼리를 실행하고 DB에서 식별자를 조회한다 


### 권장하는 식별자 전략
- 기본 키 제약 조건 : null 아님, 유일, 변하면 안된다
- 미래까지 이 조건을 만족하는 자연키는 찾기 어렵다 (대리키, 대체키를 사용하자)
- 예를 들어 주민등록번호도 기본 키로 적절하지 않다
- 권장 : Long 형 + 대체키 + 키 생성 전략 사용


### allocationSize = 50인 이유
- 시퀀스를 한 번 호출한 후 메모리에 저장해 놓고, 다음 allocationSize 값까지 DB에 접근하지 않고 메모리에서 꺼내서 사용한다
- 서버가 꺼지면 메모리에 데이터가 날라가기 때문에 PK가 일정하게 저장되지 않는다

----------------------------------------------------------------------------------------------------------------------------------

> ## 실전 예제 1 - 요구사항 분석과 기본 매핑

### 도메인 모델 분석
- 회원과 주문의 관계
  - 회원은 여러 번 주문할 수 있다 (일 대 다)
- 주문과 상품의 관계
  - 주문할 때 여러 상품을 선택할 수 있다
  - 반대로 같은 상품도 여러 번 주문될 수 있다
  - 주문 상품이라는 모델을 만들어서 다대다 관계를 해소했다


### 데이터 중심 설계의 문제점
- 현재 방식은 객체 설계를 테이블 설계에 맞춘 방식
- 테이블의 외래키를 객체에 그대로 가져옴
- 객체 그래프 탐색이 불가능
- 참조가 없으므로 UML도 잘못됨
















