
# 객체지향 쿼리 언어 1 - 기본 문법

-----------------------------------------------------------------------------------------------------------------------------------

> ## 소개

### JPA는 다양한 쿼리 방법을 지원
- JPQL
- JPA Criteria
- QueryDSL
- 네이티브 SQL
- JDBC API 직접 사용, MyBatis, SpringJdbcTemplate 함께 사용


### JPQL 소개
- JPQL 엔티티 객체를 대상으로 쿼리를 수행한다 (객체지향 SQL)
- 단점
    - 동적 쿼리를 만들기 어렵다


### JPA Criteria
    CriteriaBuilder cb = em.getCriteriaBuilder();
    CriteriaQuery<Member> query =  cb.createQuery(Member.class);

    Root<Member> m = query.from(Member.class);
    CriteriaQuery<Member> cq = query.select(m);
    ...
- 자바 코드를 통해 쿼리를 짤 수 있다
- JPQL 빌더 역할
- 단점
  - 너무 복잡하고 실용성이 없다
- 실무에서는 거의 사용하지 않는다 (QueryDSL 사용 권장)


### QueryDSL
- 자바 코드로 JPQL을 작성할 수 있다
- 단순하고 쉬움 (실무 사용 권장)


### 네이티브 SQL
- JPA가 제공하는 SQL을 직접 사용하는 기능


### JDBC 직접 사용
- JDBC 커넥션을 직접 사용하거나, 스프링 JdbcTemplate, MyBatis 등을 함께 사용 가능
- 영속성 컨텍스트를 적절한 시점에 강제로 플러시 필요
- JPA를 우회해서 SQL을 실행하기 직전에 영속성 컨텍스트 수동 플러시 필요


### 주의
- JPQL 같은 JPA 기술로 쿼리를 수행하면 commit()하지 않아도 자동으로 persist()를 수행한 후 select를 수행한다 
- JDBC 직접 사용하는 경우, persist()를 수동 플러시한 후 조회해야 제대로 된 결과를 얻을 수 있다

-----------------------------------------------------------------------------------------------------------------------------------

> ## 기본 문법과 쿼리 API

### JPQL Java Persistence Query Language
- JPQL 객체지향 쿼리 언어지만 결국 SQL로 변환된다


### JPQL 문법
- 엔티티와 속성은 대소문자 구분 O (Member, age)
- JPQL 키워드는 대소문자 구분 X (SELECT, select, FROM, from)
- 엔티티 이름 사용, 테이블 이름이 아님 (따로 설정하지 않으면 클래스 이름)
- 별칭은 필수 (m)


### 집합과 정렬
- COUNT, MAX, MIN, ... 등은 모두 사용가능


### TypeQuery, Query
    em.createQuery(...);
- TypeQuery : 반환 타입이 명확할 때 사용
- Query : 반환 타입이 명확하지 않을 때 사용


### 결과 조회 API
- query.getResultList()
  - 결과가 하나 이상인 경우
  - 결과가 없으면 빈 리스트 반환
- query.getSingleResult()
  - 결과가 하나인 경우
  - 결과가 없으면 NoResultException 발생
  - 둘 이상이면 NonUniqueResultException 발생


### 파라미터 바인딩
    // 이름 기준
    em.createQuery("SELECT m from Member m where m.username = :username", Member.class)
                        .setParameter("username", "member1");

    // 위치 기준
    em.createQuery(SELECT m FROM Member m where m.username = ?1)
                        .setParameter(1, "member1");

-----------------------------------------------------------------------------------------------------------------------------------

> ## 프로젝션

### 프로젝션
- SELECT 절에 조회할 대상을 지정하는 것
- 프로젝션 대상
  - 엔티티
  - 임베디드 타입 (FROM 절에 엔티티를 입력해야 한다)
  - 스칼라 타입(숫자, 문자 등 기본 데이터 타입)
- DISTINCT로 중복 제거


### JPQL 쿼리 작성
- SQL과 비슷하게 작성해야 다른 개발자들과 소통하는데 불편함이 없다

-----------------------------------------------------------------------------------------------------------------------------------

> ## 페이징

### 페이징 API
- JPA는 페이징을 다음 두 API로 추상화
- setFirstResult(int startPosition) : 조회 시작 위치 (0부터 시작)
- setMaxResults(int maxResult) : 조회할 데이터 수

-----------------------------------------------------------------------------------------------------------------------------------

> ## 조인

### 조인
- 내부 조인
  - SELECT m from Member m [INNER] JOIN m.team t
- 외부 조인
  - SELECT m FROM Member m LEFT [OUTER] JOIN m.team t
- 세타 조인
  - select count(m) from Member m, Team t where m.username = t.name
  - 연관 관계가 없는 경우 사용


### ON 절을 활용한 조인 (JPA 2.1부터)
1. 조인 대상 필터링
2. 연관관계 없는 엔티티 외부 조인 (하이버네이트 5.1부터)

-----------------------------------------------------------------------------------------------------------------------------------

> ## 서브 쿼리

### 서브 쿼리 지원 함수
- EXISTS : 서브쿼리에 결과가 존재하면 참
  - {ALL, ANY, SOME}
  - ALL 모두 만족하면 참
  - ANY, SOME : 조건을 하나라도 만족하면 참
- IN : 서브쿼리의 결과 중 하나라도 같은 것이 있으면 참


### JPA 서브 쿼리 한계
- JPA는 WHERE, HAVING 절에서만 서브 쿼리 사용 가능
- SELECT 절도 가능 (하이버네이트에서 지원)
- FROM 절의 서브 쿼리는 현재 JPQL에서 불가능
  - 조인으로 풀 수 있으면 풀어서 해결
  - 꼭 써야 된다면 Native SQL 

-----------------------------------------------------------------------------------------------------------------------------------

> ## JPQL 타입 표헌과 기타식

### JPQL 타입 표현
- 문자 : 'Hello', 'she''s'
- 숫자 : 10L(Long), 10D(Double), 10F(Float)
- Boolean : TRUE, FALSE
- ENUM : 패키지이름.클래스이름
- 엔티티 타입 : TYPE(m) = Member (상속 관계에서 사용)


### 자식 엔티티
    em.createQuery(SELECT i from Item i where type(i) = Book", Item.class)
- DType을 조회 조건으로 사용하는 방법
- @@DiscriminatorColumn 


### JPQL 기타
- EXISTS, IN
- AND, OR, NOT
- =, >, ...
- BETWEEN, LIKE, IS NULL

-----------------------------------------------------------------------------------------------------------------------------------

> ## 조건식 CASE 등

### 기본 CASE 식
    CASE 
        when 조건1 then 결과1
        when 조건2 then 결과2
        ...
        else 결과n
    end


### 단순 CASE 식
    CASE 컬럼값
        WHEN 조건 컬럼값1 then 결과1
        when 조건 컬럼값2 then 결과2
        ...
        else 결과n
    END


### COALESCE 식
    select coalesce(m.username, "이름 없는 회원") from Member m
- 사용자 이름이 없으면 이름 없는 회원을 반환


### NULLIF 
    select nullif(m.username, '관리자') from Member m
- 사용자 이름이 '관리자'면 null을 반환하고 나머지는 본인의 이름을 반환

-----------------------------------------------------------------------------------------------------------------------------------

> ## JPQL 함수

### JPQL 기본 함수
- CONCAT
- SUBSTRING
- TRIM
- LOWER, UPPER
- LEGNTH
- LOCATE
- ABS, SQRT, MOD
- SIZE, INDEX (JPA 용도)
  - INDEX는 왠만하면 사용하지 말자 (List 값 타입 변수가 있을 때 인덱스를 부여하여 위치를 확인할 수 있음)


### 사용자 정의 함수
    select function('group_concat', i.name) from Item i
- 사용하는 DB 방언을 상속받고, 사용자 정의 함수를 등록해야 한다
- DB 종속적인 함수는 방언에 등록되어 있다


### 사용자 정의 함수 예시
    public class MyH2Dialect extends H2Dialect {

    // 함수 등록
    public MyH2Dialect() {
        this.registerFunction("acos", new StandardSQLFunction("acos", StandardBasicTypes.DOUBLE));
    }
1. DB에서 함수 만들기
2. 클래스를 하나 만들고 사용하는 방언을 상속받기 
3. registerFunction() 함수를 통해 DB 상속 등록하기
4. persistence.xml에 내가 만든 클래스를 방언으로 등록하기

















