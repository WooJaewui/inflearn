
# 객체지향 쿼리 언어 2 - 중급 문법

-----------------------------------------------------------------------------------------------------------------------------------

> ## 경로 표현식

### 경로 표현식
- .(점)을 찍어서 객체 그래프를 탐색하는 것


### 경로 표현식 용어 정리
- 상태 필드 state field 
  - 단순히 값을 저장하기 위한 필드
- 연관 필드 association field
  - 연관 관계를 위한 필드
    - 단일 값 연관 필드 : @ManyToOne, @OneToOne
    - 컬렉션 값 연관 필드 : @OneToMany, @ManyToMany


### 경로 표현식 특징
- 상태 필드 : 경로 탐색의 끝, 더이상 탐색 X
- 단일 값 연관 경로 : 묵시적 내부 조인 발생, 탐색 O
- 컬렉션 값 연관 경로 : 묵시적 내부 조인 발생, 탐색 X


### 명시적 조인, 묵시적 조인
- 명시적 조인 : join 키워드 직접 사용
- 묵시적 조인 : 경로 표현식에 의해 묵시적으로 SQL 조인 발생 (내부 조인만 가능)


### 경로 탐색을 사용한 묵시적 조인 시 주의사항
- 항상 내부 조인
- 컬렉션은 경로 탐색의 끝, 명시적 조인을 통해 별칭을 얻어야 함
- SQL의 FROM (JOIN) 절에 영향을 줌


## 실무 조언
- 가급적 묵시적 조인 대신에 명시적 조인 사용
- 조인은 SQL 튜닝에 중요 포인트
- 묵시적 조인은 조인이 일어나는 상황을 한눈에 파악하기 어려움

-----------------------------------------------------------------------------------------------------------------------------------

> ## 페치 조인 1 - 기본

### 페치 조인 fetch join
- SQL 조인 X
- JPQL에서 성능 최적화를 위해 제공하는 기능
- 연관된 엔티티나 컬렉션을 SQL 한 번에 함께 조회하는 기능


### 사용 방법
    select m from Member m join fetch m.team


### 컬렉션 페치 조인
    SELECT t 
    from Team t 
    join fetch t.members
    where t.name = '팀A';


### JPQL DISTINCT 기능
1. SQL에 DISTINCT 추가
2. 어플리케이션에서 엔티티 중복 제거


### SQL DISTINCT
- 모든 데이터가 같아야 중복 제거 됨


### 페치 조인과 일반 조인의 차이
- 일반 조인 실행시 연관된 엔티티를 함께 조회하지 않음
- 페치 조인은 객체 그래프를 SQL 한번에 조회하는 개념

-----------------------------------------------------------------------------------------------------------------------------------

> ## 페치 조인 2 - 한계

### 페치 조인의 특징과 한계
- 페치 조인 대상에는 별칭을 주지 않는 것이 관례다
  - casCade 같은 옵션이 걸려 있으면, 조회되지 않은 컬렉션 멤버도 같이 삭제될 수 있다
  - 컬렉션 안에서 또 다른 fetch join을 해야 될 때는 사용가능
- 둘 이상의 컬렉션은 페치 조인할 수 없다
  - 1:다:다 조인이기 때문에 문제가 발생할 수 있다
- 컬렉션을 페치 조인하면 페이징 API (setFirstResult, setMaxResult)를 사용할 수 없다
  - 일대일, 다대일 같은 단일 값 연관 필드들은 페치 조인해도 페이징 가능
  - 하이버네이트는 경고 로그를 남기고 메모리에서 페이징 (매우 위험)
- 연관된 엔티티들을 SQL 한 번으로 조회 (성능 최적화)
- 최적화가 필요한 곳은 페치 조인 적용 (대부분의 성능 문제를 해결할 수 있다)


### 배치 사이즈 설정
    // 어노테이션 (해당 변수에 설정)
    @BatchSize(100)
    // persistence.xml (글로벌)
    <property name="hibernate.default_batch_fetch_size" value="100"/> 
- 1000 이하의 값으로 설정


### 페치 조인 - 정리
- 모든 것을 페치 조인으로 해결할 수는 없다
- 여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야 하면 일반 조인을 사용하고 필요한 데이터들만 DTO로 반환하는 것이 효과적

-----------------------------------------------------------------------------------------------------------------------------------

> ## 다형성 쿼리

### TYPE
    select i from Item i
    where type(i) in (Book, Movie)


### TREAT
    select i from Item i
    where treat(i as Book).author = 'kim'
- 자바의 타입 캐스팅과 유사
- FROM, WHERE, SELECT

-----------------------------------------------------------------------------------------------------------------------------------

> ## 엔티티 직접 사용

### 엔티티 직접 사용
    // JPQL
    select count(m) from Member m

    // SQL
    select count(m.id) as cnt from MEMBER m
- JPQL에서 엔티티를 직접 상요하면 SQL에서 해당 엔티티의 기본키 값을 사용

-----------------------------------------------------------------------------------------------------------------------------------

> ## Named 쿼리

### Named 쿼리 - 정적 쿼리
    @Entity
    @NamedQuery(
        name = "Member.findByUsername"
        query = "select m from Member m where m = :member"
    )
    class ...
- 미리 정의해서 이름을 부여해두고 사용하는 JPQL
- 정적 쿼리
- 어노테이션, XML에 정의
- 어플리케이션 로딩 시점에 초기화 후 재사용
- 어플리케이션 로딩 시점에 쿼리를 검증


### Named 쿼리 우선권
- XML 파일이 항상 우선권을 갖는다
- 어플리케이션 운영 환경에 따라 다른 XML을 배포할 수 있다


### XML 정의
    // persistence.xml
    <mapping-file>META-INF/파일이름.xml</mapping-file>

    // 파일이름.xml
    <named-query name="Member.findByUsername">
      <query>
        select m 
        from Member m
        where m.username = :username
      </query>
    </named-query>


### 스프링 Data JPA
    public interface UserRepository extends JpaRepository<User, Long> {
        @Query("select u from User u where u.emailAddress = ?1")
        User findByEmailAddress(String emailAddress);
    }

-----------------------------------------------------------------------------------------------------------------------------------

> ## 벌크 연산

### 벌크 연산 예시
- 재고가 10개 미만인 모든 상품의 가격을 10% 상승하려면?
- JPA 변경 감지 기능으로 실행하려면 너무 많은 SQL 실행
    1. 재고가 10개 미만인 상품을 리스트로 조회한다
    2. 상품 엔티티의 가격을 10% 증가한다
    3. 트랜잭션 커밋 시점에 변경 감지가 동작한다
- 변경된 데이터가 100건이라면 100번의 UPDATE SQL 실행


### 벌크 연산 쿼리
    em.createQuery("update Member m set m.age = 20")
              .executeQuery();


### 벌크 연산 주의
- 벌크 연산은 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리
  - 벌크 연산을 제일 먼저 실행
  - 벌크 연산 수행 후 영속성 컨텍스트 초기화 (데이터 조회 후 사용)

















