
# MVC 프레임워크 만들기.

-------------------------------------------------------------------------------------------------------------------------------

> ## 프론트 컨트롤러 패턴 소개.

### FrontController 패턴 특징.
- 프론트 컨트롤러 서블릿 하나로 클라이언트의 요청을 받음.
- 프론트 컨트롤러가 요청에 맞는 컨트롤러를 찾아서 호출.
- 입구를 하나로!
- 공통 처리 가능.
- 프론트 컨트롤러를 제외한 나머지 컨트롤러는 서블릿을 사용하지 않아도 됨.

### 스프링 웹 MVC와 프론트 컨트롤러.
- 스프링 웹 MVC의 핵심도 바로 FrontController.
- 스프링 웹 MVC의 DispatcherServlet이 FrontController 패턴으로 구현되어 있음.

-------------------------------------------------------------------------------------------------------------------------------

> ## 프론트 컨트롤러 도입 - v1.

### v1 구조.
- 클라이언트 -> HTTP 요청 -> 프론트 컨트롤러 -> 매핑 정보 -> 컨트롤러 호출 -> 컨트롤러에서 JSP forward -> JSP -> HTML 응답.

### ControllerV1.
- 서블릿과 비슷한 모양의 컨트롤러 인터페이스를 도입한다.
- 각 컨트롤러들은 이 인터페이스를 구현하면 된다.
- 프론트 컨트롤러는 이 인터페이스를 호출해서 구현과 관계없이 로직의 일관성을 가져갈 수 있다.

### URI 얻는 방법.
    request.getRequestURI();

### 김영한 강사님 팁.
- 리팩터링을 할 때 같은 레벨에 맞는 것들을 한번에 수정해얗 한다.
- 구조를 개선할 때와 디테일한 코드를 개선할 때 리팩터링을 나눠서해야 한다.
- HTML에서 경로를 지정할 때 대부분 절대 경로를 사용한다.

### url.
- urlPatterns = "/abc/*" 는 "/abc"를 포함한 하위 모든 요청을 받아들인다.

-------------------------------------------------------------------------------------------------------------------------------

> ## View 분리 - v2.

### v2 구조.
- 클라이언트 -> HTTP 요청 -> 프론트 컨트롤러 -> 매핑 정보 -> 컨트롤러 호출 -> 뷰 정보를 프론트 컨트롤러에 보냄<br>
  -> 뷰 정보를 바탕으로 뷰로 forward -> HTML 응답.

### FrontController.
- 생성자에서 URL 매핑 정보 조회.
- 클라이언트 요청 url을 통해 URL 매핑 정보와 매핑.
- Controller에서 view 정보를 받아와서 view로 forward.

-------------------------------------------------------------------------------------------------------------------------------

> ## Model 추가 - v3.

### 서블릿 종속성 제거.
- 컨트롤러 입장에서 HttpServletRequest, HttpServletResponse가 필요 없는 상황이 있다.
- 요청 파라미터 정보는 자바의 Map으로 대신 넘기도록하면 지금 구조에서는 컨트롤러가 서블릿 기술을 몰라도 동작할 수 있다.
- 그리고 request 객체를 Model로 사용하는 대신에 별도의 model 객체를 만들어서 반환하면 된다.
- 우리가 구현하는 컨트롤러가 서블릿 기술을 전혀 사용하지 않도록 변경해보자.
- 이렇게 하면 구현 코드도 매우 단순해지고, 테스트 코드 작성이 쉽다.

### 뷰 이름 중복 제거.
- 컨트롤러에서 지정하는 뷰 이름에 중복이 있는 것을 확인할 수 있다.
- 컨트롤러는 뷰의 논리 이름을 반환하고, 실제 물리 위치의 이름은 프론트 컨트롤러에서 처리하도록 단순화하자.
- 이렇게 해두면 향후 뷰의 폴더 위치가 함께 이동해도 프론트 컨트롤러만 고치면 된다.

### V3 구조.
- 클라이언트 -> HTTP 요청 -> 프론트 컨트롤러 매핑 정보 조회 -> 컨트롤러 호출 -> ModelView 반환 -> Controller에서 ViewResolver 반환<br>
  -> MyView 반환 -> Controller에서 뷰로 forward.

### ModelView.
- 서블릿의 종속성을 제거하기 위해 Model을 직접 만들고, 추가로 View 이름까지 전달하는 객체를 만들어보자.
- 참고로 modelView 객체는 다른 버전에서 사용하기 때문에 frontconller 패키지에 둔다.

-------------------------------------------------------------------------------------------------------------------------------

> ## 단순하고 실용적인 컨트롤러 - v4.

### 좋은 프레임워크.
- 좋은 프레임워크는 아키텍처도 중요하지만, 그와 더불어 실제 개발하는 개발자가 단순하고 편리하게 사용할 수 있어야 한다.
- 실용성이 있어야 한다.

### 개선 방식.
- frontController에서 Model을 생성해서 Controller로 넘겨준다.
- 컨트롤러에서 모델 객체에 값을 담으면 여기에 그대로 담겨지게 된다.

### 정리.
- 이번 버전의 컨트롤러는 매우 단순하고 실용적이다.
- 기존 구조에서 모델을 파라미터로 넘기고, 뷰의 논리 이름을 반환한다는 작은 아이더를 적용했을 뿐이다.
- 프레임워크가 점진적으로 발전하는 과정 속에서 이런 방법도 찾을 수 있었다.
- 프레임워크나 공통 기능이 수고로워야 사용하는 개발자가 편리해진다.

-------------------------------------------------------------------------------------------------------------------------------

> ## 유연한 컨트롤러1 - v5.

### 개요.
- 만약 어떤 개발자는 'ControllerV3' 방식으로 개발하고 싶고, 어떤 개발자는 'ControllerV4' 방식으로 개발하고 싶다면 어떻게 해야할까?

### 어댑터 패턴.
- 지금까지 우리가 개발한 프론트 컨트롤러는 한가지 방식의 컨트롤러 인터페이스만 사용할 수 있다.
- 어댑터 패턴을 사용해서 프론트 컨트롤러가 다양한 방식의 컨트롤러를 처리할 수 있도록 변경해보자.

### V5 구조.
- 핸들러 어댑터.
  - 중간에 어댑터가 추가되었는데 이름이 핸들러 어댑터이다.
  - 여기서 어댑터 역할을 해주는 덕분에 다양한 종류의 컨트롤러를 호출할 수 있다.
- 핸들러.
  - 컨트롤러의 이름을 더 넓은 범위인 핸들러로 변경했다.
  - 그 이유는 이제 어댑터가 있기 때문에 꼭 컨트롤러의 개념뿐만 아니라 어떠한 것이든 해당하는 종류의 어댑터만 있으면 다 처리할 수 있기 때문이다.
  
### MyHandlerAdapter.
- supports(Object handler)
  - handler는 컨트롤러를 말한다.
  - 어댑터가 해당 컨트롤러를 처리할 수 있는지 판단하는 메서드다.
- handle(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException
  - 어댑터는 실제 컨트로러를 호출하고, 그 결과로 ModelView를 반환해야 한다.
  - 실제 컨트롤러가 modelView를 반환하지 못하면,어댑터가 ModelView를 직접 생성해서라도 반환해야 한다.
  - 이전에는 프론트 컨트롤러가 실제 컨트롤러를 호출했지만 이제는 이 어댑터를 통해서 실제 컨트롤러가 호출된다.

-------------------------------------------------------------------------------------------------------------------------------

> ## 유연한 컨트롤러2 - v5.

### 인터페이스의 중요성.
- 코드를 수정하지 않고 OCP를 지키면서 수정/확장할 수 있다.

### Spring 발전과정.
- 모든 것을 인터페이스화해서 확장하기 편리하게 구조화하였다.

-------------------------------------------------------------------------------------------------------------------------------

> ## 정리.

### 지금까지 한 작업을 정리해보자.
- v1.
  - 프론트 컨트롤러를 도입. 
  - 기존 구조를 최대한 유지하면서 프론트 컨트롤러를 도입.
- v2.
  - view 분류. 
  - 단순 반복 되는 뷰 로직 분리.
- v3.
  - Model 추가. 
  - 서블릿 종속성 제거.
- v4.
  - 단순하고 실용적인 컨트롤러.
  - v3와 거의 비슷.
  - 구현 입장에서 ModelView를 직접 생성해서 반환하지 않도록 편리한 인터페이스 제공.
- v5.
  - 유연한 컨트롤러.
  - 어댑터 도입.
  - 어댑터를 추가해서 프레임워크를 유연하고 확장성 있게 설계.

### 추가 발전 사항.
- 여기에 어노테이션을 사용해서 컨트롤러를 더 편리하게 발전시킬 수도 있다.
- 어노테이션을 지원하는 어댑터를 추가하면 된다.
- 다형성과 어댑터 덕분에 기존 구조를 유지하면서, 프레임워크의 기능을 확장할 수 있다.

### 스프링 MVC.
- 스프링 MVC의 핵심 구조를 파악하는데 필요한 부분은 모두 만들어보았다.
- 지금까지 작성한 코드는 스프링 MVC 프레임워크의 핵심 코드의 축약 버전이고, 구조도 거의 같다.

### RequestMappingHandlerAdapter.
- @RequestMapping을 처리해주는 Adapter이다.

### 띵언.
- 프레임워크나 공통 기능이 수고로워야 사용하는 개발자는 편리해진다.






















