
 스프링 핵심 원리 이해2 - 객체 지향 원리 적용.



 # 새로운 할인 정책 개발.

static import.
static import하면 클래스 이름을 생략해서 사용할 수 있다.

단축키.
crtl + shift + t : 테스트 클래스 만들기.
alt + enter : static import 적용 가능.
ctrl + e : 히스토리 확인 가능.



 # 새로운 할인 정책 적용과 문제점.

DIP 문제 발생.
인터페이스뿐만 아니라 구현 객체까지 의존하고 있다.
새로운 기능을 확장하면 소스코드를 변경해줘야 한다.

DIP 문제 해결 방식.
인터페이스에만 의존하도록 소스코드를 바꿔준다.



 # 관심사의 분리.

관심사의 분리.
하나의 클래스에서는 최소한의 책임만을 가지게 설계해야 된다.

AppConfig 등장.
구현 객체를 생성하고 연결하는 책임을 가지는 별도의 설정 클래스.

의존주입.
생성자의 파라미터로 구현객체를 외부에서 주입받아서 사용하는 방법.
구현객체 입장에서 보면 의존관계를 마치 외부에서 주입해주는 것과 같다. - 의존성 주입.



 # AppConfig 리팩터링.

AppConfig 리팩터링.
구현 객체를 메소드로 따로 생성해서 애플리케이션 전체 구성이 어떻게 되어있는지 빠르게 파악할 수 있다.



 # 새로운 구조와 할인 정책 적용.

AppConfig의 역할.
사용 영역과 구성 영역이 완전히 분리되었다.
사용 영역 코드는 수정하지 않고 구성 영역에서 구현 객체를 변경해서 사용.
DIP, OCP 문제점을 모두 해결.



 # 좋은 객체 지향 설계의 5가지 원칙의 적용.

SRP 단일 책임 원칙.
한 클래스는 하나의 책임만 가져야한다.
구현 객체를 생성하고 연결하는 책임은 AppConfig가 담당.

DIP 의존관계 역전 원칙.
추상화에 의존하고, 구체화에 의존하면 안된다.
AppConfig가 객체 인스턴스를 코드에 의존관계 주입했다.

OCP 개방/폐쇄 원칙.
소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
AppConfig만 변경하면 서비스 코드를 변경하지 않아도 된다.



 # IoC, DI, 그리고 컨테이너.

제어의 역전 IoC Inversion of Control.
프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 의미한다.

프레임워크 vs 라이브러리.
내가 작성한 코드를 제어하고 대신 실행하면 프레임워크다.
내가 작성한 코드가 직접 제어의 흐름을 담당한다면 라이브러리이다.

의존관계 주입 DI Dependency Injection.
정적인 클래스 의존관계와, 실행 시점에 결정되는 동적인 객체 의존관계 둘을 분리해서 생각해야 한다.

정적인 클래스 의존관계.
클래스가 사용하는 import 코드만 보고 의존관계를 쉽게 판단할 수 있다.
애플리케이션을 실행하지 않아도 분석할 수 있다.

동적인 객체 인스턴스 의존관계.
애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계.

IoC 컨테이너, DI 컨테이너.
AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 의미한다.
의존관계 주입에 초점을 맞추어 최근에는 주로 DI 컨테이너라고 부른다.



 # 스프링으로 전환하기.

@Configuration.
스프링 설정 파일을 의미하는 어노테이션.

@Bean.
ApplicationContext( DI 컨테이너 )에 구현 객체를 저장한다.

사용방법.
ApplicationContext ap = new AnnotationConfigApplicationContext( AppConfig.class ) ;
AService aService = ap.getBean( "이름" , AService.class ) ;

ApplicationContext.
DI 컨테이너보다 확장된 개념으로 스프링 컨테이너라고 부른다.
@Configuration이 붙은 클래스를 설정 정보로 사용한다.
@Bean이 붙은 메소드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다.
스프링 빈은 @Bean이 붙은 메소드의 이름을 스프링 빈의 이름으로 사용한다.






