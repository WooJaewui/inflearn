
 의존관계 자동 주입.



 # 다양한 의존관계 주입 방법.

의존관계 주입 방법.
생성자 주입.
수정자 주입( setter 주입 )
필드 주입.
일반 메소드 주입.

생성자 주입.
생성자를 통해서 의존 관계를 주입 받는 방법이다.
생성자 호출시점에 딱 1번만 호출되는 것이 보장된다.
불변 의존관계에 사용. ( setter메소드를 만들지 않는다 )
필수 의존관계에 사용. ( 항상 필요한 데이터에 사용 )
생성자가 딱 1개만 있다면 @Autowired 생략할 수 있다.

수정자 주입.
setter라 불리는 필드의 값을 변경하는 수정자 메소드를 통해서 의존관계를 주입하는 방법이다.
선택, 변경 가능성이 있는 의존관계에 사용. ( 필수 X , 도중에 변경 가능 )

필드 주입.
필드에다가 직접 값을 직접 주입하는 것이다.
코드가 간결해서 많은 개발자들을 유혹하지만 외부에서 변경이 불가능해서 테스트 하기 힘들다.
DI 프레임워크가 없으면 아무것도 할 수 없다.
간단한 테스트 코드를 작성할 때만 사용하자.

일반 메소드 주입.
한번에 여러 필드를 주입 받을 수 있다.
일반적으로 거의 사용하지 않는다.

주의사항.
의존관계 주입은 스프링 컨테이너가 관리하는 스프링 빈이어야 동작한다.



 # 옵션 처리.

Autowired 옵션.
@Autowired( required=false ) : 자동 주입할 대상이 없으면 수정자 메소드 자체가 호출 안됨.
@Nullable : 자동 주입할 대상이 없으면 호출 되고 'Null' 이 입력된다.
Optional<> : 자동 주입할 대상이 없으면 'Optional.empty' 가 입력된다.



 # 생성자 주입을 선택해라 !

불변.
대부분의 의존관계 주입은 한 번 일어나면 애플리케이션 종료시점까지 의존관계를 변경할 일이 없다.
수정자 주입을 사용하면, setter 메소드를 public으로 열어두어야 한다. ( 누군가 실수로 변경할 수 있다 )

누락.
생성자에서 만들면 누락시 컴파일 Exception이 발생해서 누락할 일이 없다.

final 키워드.
생성자 주입을 사용하면 필드에 final 키워드를 사용할 수 있다. ( 생성자 주입만 final 가능 )



 # 롬복과 최신 트랜드.

롬복 설정.
1. gradle에 추가하기.
2. file -> Settings -> plugins -> lombok 설치.
3. file -> Settings -> Annotation Processors -> Enable annotation processing 체크.

@RequiredArgsConstructor.
final이 붙은 필드에 대한 생성자를 만들어준다.
롬복 라이브러리가 제공한다.



 # 조회 빈이 2개 이상 - 문제.

@Autowired 문제점.
type으로 bean을 조회해서 자동 주입시켜준다. ( NoUniqueBeanDefinitionException )



 # @Autowired 필드 명, @Qualifier, @Primary.

@Autowired 매칭 정리.
1. 타입 매칭.
2. 타입 매칭의 결과가 2개 이상일 때 필드 명, 파라미터 명으로 이름 매칭.

@Qualifier.
주입받으려는 클래스에 @Qualifier( "이름" )으로 설정하고 주입받을 때 @Qualifier( "이름" )으로 매칭.
@Qualifier( "이름" )으로 찾지 못하면 이름으로 된 스프링 빈을 찾는다.

@Primary.
@Autowired 시에 여러 빈이 매칭되면 @Primary가 우선권을 갖는다.

우선순위.
@Primary와 @Qualifier가 둘 다 적용되어 있으면 @Qualifier가 우선순위가 높다.
스프링은 자동보다는 수동이 , 넓은 범위의 선택권 보다는 좁은 범위의 선택권이 우선 순위가 높다.



 # 애노테이션 직접 만들기.

애노테이션 필요성.
@애노테이션( "값" ) 등의 값을 문자열로 입력해야 되는 경우에는 RunnableException이 발생한다.
애노테이션을 직접 만들어서 CompileException이 발생하도록 유도할 수 있다.

애노테이션 특징.
애노테이션에는 상속이라는 개념이 없다. 
여러 애노테이션을 모아서 사용하는 기능은 스프링이 지원해주는 기능이다.
무분별하게 재정의 하는 것은 유지보수에 더 혼란만 가중할 수 있다.



 # 조회한 빈이 모두 필요할 때 , List , Map.

여러 개의 빈을 모두 DI.
private final Map<String, 객체> map ;
@Autowired
public 객체이름( Map<String, 객체> map ) { 
	this.map = map ;
}



 # 자동, 수동의 올바른 실무 운영 기준.

대부분의 경우.
편리한 자동 기능을 기본으로 사용하자.

수정 빈 등록 사용.
애플리케이션에 광범위하게 영향을 미치는 기술 지원 객체는 수동 빈으로 등록해서
설정 정보에 바로 나타나게 하는 것이 유지보수 하기 좋다.
다형성을 적극적으로 활용하는 비즈니스 로직은 수동 등록을 고민해보자.
핵심은 다른사람이 보고 이해가 될 수 있도록 만드는 것이다.

단축키.
ctrl + alt + b : 마우스 오버한 하위 객체를 모두 보여줌.






