
# 스프링 시큐리티 주요 아키텍처 이해

------------------------------------------------------------------------------------------------------------------------

> ## 위임 필터 및 필터 빈 초기화 - DelegatingProxyChain, FilterChainProxy

### 영어 단어
- delegating : 위임하다


### DelegatingFilterProxy
- 서블릿 필터는 스프링에서 정의된 빈을 주입해서 사용할 수 없음 (Servlet Filter는 서블릿 컨테이너에 존재하기 때문)
- 특정한 이름을 가진 스프링 빈을 찾아 그 빈에게 요청을 위임
  - springSecurityFilterChain 이름으로 생성된 빈을 ApplicationContext에서 찾아 요청을 위임
  - 실제 보안처리를 하지 않음


### FilterChainProxy
1. springSecurityFilterChain의 이름으로 생성되는 필터 빈
2. DelegatingFilterProxy으로 부터 요청을 위임 받고 실제 보안 처리
3. 스프링 시큐리티 초기화 시 생성되는 필터들을 관리하고 제어
   - 스프링 시큐리티가 기본적으로 생성하는 필터
   - 설정 클래스에서 API 추가 시 생성되는 필터
4. 사용자의 요청을 필터 순서대로 호출하여 전달
5. 사용자정의 필터를 생성해서 기존의 필터 전.후로 추가 가능
    - 필터의 순서를 잘 정의
6. 마지막 필터까지 인증 및 인가 예외가 발생하지 않으면 보안 통과


### WebSecurityConfiguration
- Security 관련 configure 클래스
- FilterChainProxy를 "springSecurityFilterChain" 이름으로 빈을 등록

------------------------------------------------------------------------------------------------------------------------

> ## 필터 초기화와 다중 보안 설정

### WebSecurityConfigurerAdapter가 여러 개인 경우 (다중 보안 설정)
- 설정 클래스 별로 보안 기능이 각각 작동
- 설정 클래스 별로 RequestMatcher 설정
  - http.antMatcher("/admin/**")
- 설정 클래스 별로 필터가 생성
- FilterChainProxy가 각 필터들을 가지고 있음
- 요청에 따라 RequestMatcher와 매칭되는 필터가 작동하도록 함


### FilterChainProxy
    @Bean @Order(1)
    public SecurityFilterChain filterChain1(HttpSecurity http) throws Exception { ... }
    @Bean @Order(2)
    public SecurityFilterChain filterChain2(HttpSecurity http) throws Exception { ... }
- @Bean으로 등록한 SecurityFilterChain 개수만큼 Security 설정을 확인하고, match되는 FilterChain을 수행한다
- FilterChainProxy에 @Bean으로 등록한 모든 SecurityFilterChain의 List를 인스턴스 변수를 가지고 있음
- @Order(int) 순서에 따라 보안을 수행함

------------------------------------------------------------------------------------------------------------------------

> ## 인증 개념 이해 - Authentication

### 영어 단어
- principal : 주요한


### Authentication 인터페이스
    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();     // Authentication 얻기
- 당신이 누구인지 증명하는 것
  - 사용자의 인증 정보를 저장하는 토큰 개념
  - 인증 시 id, password를 담고 인증 검증을 위해 전달되어 사용된다
  - 인증 후 최종 인증 결과 (user 객체, 권한 정보)를 담고 SecurityContext에 저장되어 전역적으로 참조가 가능하다
- 구조
  - principal : 사용자 아이디 혹은 User 객체를 저장
  - credentials : 사용자 비밀번호
  - authorities : 인증된 사용자의 권한 목록
  - details : 인증 부가 정보
  - authenticated : 인증 여부


### Authentication 인증 실행 순서
1. 클라이언트 username + password 로그인 요청
2. UsernamePasswordAuthenticationFilter에서 Authentication을 생성
   - principal : username
   - credentials : password
   - authenticated : false
3. AuthenticationManager를 통해 로그인 인증 체크
4. 인증 성공 후 Authentication 내용 변경
   - principal : UserDetails 클래스
   - credentials : --- (보안 상 비워둔다)
   - authenticated : true
5. Authentication을 SecurityContextHolder에 저장
   - 인증 객체를 전역적으로 사용 가능

------------------------------------------------------------------------------------------------------------------------

> ## 인증 저장소 - SecurityContextHolder, SecurityContext

### SecurityContext
- Authentication 객체가 저장되는 보관소로 필요 시 언제든지 Authentication 객체를 꺼내어 쓸 수 있도록 제공되는 클래스
- ThreadLocal에 저장되어 아무 곳에서나 참조가 가능하도록 설계함
- 인증이 완료되면 HttpSession에 저장되어 어플리케이션 전반에 걸쳐 전역적인 참조가 가능하다


### SecurityContextHolder
- SecurityContext 객체 저장 방식
  - MODE_THREADLOCAL : 쓰레드당 SecurityContext 객체를 할당 (기본값)
  - MODE_INHERITABLETHREADLOCAL : 메인 쓰레드와 자식 쓰레드에 관하여 동일한 SecurityContext를 유지
  - MODE_GLOBAL : 응용 프로그램에서 단 하나의 SecurityContext를 저장
- SecurityContextHolder.clearContext()
  - SecurityContext 기존 정보 초기화


### Authentication 전역으로 얻는 방법
    Authentication authentication = SecurityContextHolder.getConext().getAuthentication();


### 인증 실패 시
- SecurityContextHolder.clearContext()를 통해 SecurityContext 정보 초기화


### 인증 성공 시
- SecurityContextHolder 안에 SecurityContext 안에 Authentication을 저장하고, 인증 성공 시 SecurityContext가 HttpSesion에 저장
  - session key name : SPRING_SECURITY_CONTEXT


### SecurityContextHolder 전략 변경
    SecurityContextHolder.setStrategyName(SecurityContextHolder.MODE_INHERITABLETHREADLOCAL);

------------------------------------------------------------------------------------------------------------------------

> ## 인증 저장소 필터 - SecurityContextPersistenceFilter

### SecurityContextPersistenceFilter - deprecated
- SecurityContext 객체의 생성, 저장, 조회
- 익명 사용자
  - 새로운 SecurityContext 객체를 생성하여 SecurityContextHolder에 저장
  - AnonymousAuthenticationFilter에서 AnonymousAuthenticationToken 객체를 SecurityContext에 저장
- 인증 시
  - 새로운 SecurityContext 객체를 생성하여 SecurityContextHolder에 저장
  - 인증 성공 후 SecurityContext에 UsernamePasswordAuthenticationToken 객체를 SecurityContext에 저장
  - 인증이 최종 완료되면 Session에 SecurityContext를 저장
- 인증 후
  - Session에서 SecurityContext 꺼내서 SecurityContextHolder에서 저장
  - SecurityContext 안에 Authentication 객체가 존재하면 계속 인증을 유지
- 최종 응답 시 공통
  - SecurityContextHolder.clearContext()


### 최신 버전
- SecurityContextPersistenceFilter deprecated 되고, SecurityContextHolderFilter를 사용

------------------------------------------------------------------------------------------------------------------------

> ## 인증 흐름 이해 - Authentication Flow

### Authentication Flow
1. UserPasswordAuthenticationFilter
   - UserPasswordAuthenticationToken 객체를 생성
   - AuthenticationManager에게 토큰 전달
2. AuthenticationManager
   - 인증의 전반적인 관리
   - List<AuthenticationProvider>를 변수로 가지고 있어서, Authentication 인증을 AuthenticationProvider에게 위임한다
3. AuthenticationProvider
   - 실제 인증 처리 역할
   - 유저 유효성 검증 (패스워드 체크 등)
4. UserDetailsService
    - 유저 객체 조회
    - UserDetails 타입으로 반환 
5. AuthenticationProvider
    - UserDetailsService로 부터 UserDetails를 받음
    - UserDetails + authorities를 담은 토큰 Authentication을 만듬
6. AuthenticationManager
    - AuthenticationProvider에서 생성된 Authentication 토큰을 UserPasswordAuthenticationFilter에 전달

------------------------------------------------------------------------------------------------------------------------

> ## 인증 관리자 : AuthenticationManager

### AuthenticationManager
- AuthenticationProvider 목록 중에서 인증 처리 요건에 맞는 AuthenticationProvider를 찾아 인증처리를 위임한다
- 부모 ProviderManager를 설정하여 AuthenticationProvider를 계속 탐색할 수 있다

------------------------------------------------------------------------------------------------------------------------

> ## 인증 관리자 - AuthenticationProvider

### AuthenticationProvider
- authenticate(...) 메서드를 통해 검증을 수행한다
  - ID 검증 : UserDetailsService
  - password 검증
  - 추가 검증
  - 모든 검증이 끝나면 Authentication(user, authorities)를 생성하여 AuthenticationManger에 반환
- supports(authentication) : authenticate(..) 메서드 수행 전 조건 확인

------------------------------------------------------------------------------------------------------------------------

> ## 인가 개념 및 필터 이해 : Authorization, FilterSecurityInterceptor

### Authorization
- 인증이 완료된 후에 진행된다


### 스프링 시큐리티가 지원하는 권한 계층
- 웹 계층
  - URL 요청에 따른 메뉴 혹은 화면단위의 레벨 보안
  - 사용자에 권한(ROLE) 체크
- 서비스 계층
  - 화면 단위가 아닌 메소드 같은 기능 단위의 레벨 보안
- 도메인 계층
  - 객체 단위의 레벨 보안 (이번 강의에서 다루지 않음)


### FilterSecurityInterceptor (deprecated - AuthorizationFilter로 변경)
- 마지막에 위치한 필터로써 인증된 사용자에 대하여 특정 요청의 승인/거부 여부를 최종적으로 결정
- 인증객체 없이 보호자원에 접근을 시도할 경우 AuthenticationException을 발생
- 인증 후 자원에 접근 가능한 권한이 존재하지 않을 경우 AccessDeniedException을 발생
- 권한 제어 방식 중 HTTP 자원의 보안을 처리하는 필터
- 권한 처리를 AccessDecisionManager에게 맡김


### SecurityMetadataSource
- 사용자가 요청한 자원에 필요한 권한 정보를 조회해서 전달
  - 권한 정보가 존재하는 하지 않는 경우, null일 경우 권한 심사를 하지 않음 (자원 접근 허용)
  - 권한 정보가 존재하는 경우, AccessDecisionManager에서 권한을 체크
    - 최종 권한 체크 클래스는 AccessDecisionVoter이다

------------------------------------------------------------------------------------------------------------------------

> ## 인가 결정 심의자 - AccessDecisionManager, AccessDecisionVoter

### 영어 단어
- affirm : 긍정하다
- affirmative : 긍정


### AccessDecisionManager
- 인증 정보, 요청정보, 권한정보를 이용해서 사용자의 자원접근을 허용할 것인지 거부할 것인지를 최종 결정하는 주체
- 여러 개의 Voter들을 가질 수 있으며 Voter들로부터 접근허용, 거부, 보류에 해당하는 각각의 값을 리턴받고 판단 및 결정
- 최종 접근 거부 시 예외 발생
- deprecated 되었다 (AuthorizationManager로 대체) 


### 접근 결정의 세 가지 유형
- AffirmativeBased
  - 여러 개의 Voter 클래스 중 하나라도 접근 허가로 결론을 내면 접근 허가로 판단한다
- ConsensusBased
  - 승인, 거부 다수결에 의해 최종 결정을 판단
  - 동수일경우 기본은 접근허가이나 allowIfEqualGrantedDeniedDecisions을 false로 설정할 경우 접근 거부로 결정
- UnanimousBased
  - 모든 Voter가 만장일치로 접근을 승인해야 하며 그렇지 않은 경우 접근을 거부한다


### AccessDecisionVoter
- 판단을 심사하는 것
- deprecated 됨 (AuthorizationManager로 대체)


### 최근 버전
- AccessDecisionManager, AccessDecisionVoter의 기능을 AuthorizationManager 클래스에서 수행

------------------------------------------------------------------------------------------------------------------------

> ## 스프링 시큐리티 필터 및 아키텍처 정리

### 시큐리티 전체 흐름
- 설정
  - HttpSecurity에 설정한 정보(Filters)를 WebSecurity -> FilterChainProxy로 전달
  - WebSecurityConfiguration 설정 참조
  - DelegatingFilterProxy(Servlet Bean) 역할 위임 FilterChainProxy(Spring Bean)
- 인증 요청
  - 인증 요청이 들어오면 DelegatingFilterProxy가 FilterChainProxy에게 Filter 역할을 위임
  - FilterChainProxy에 여러 filters들을 순서대로 수행


### Filers 수행 흐름
1. SecurityContextPersistenceFilter
    - HttpSessionSecurityContextRepository loadContext()를 통해 SecurityContext 데이터가 있는지 확인
    - 없으면, SecurityContext 생성
2. LogoutFilter
    - 로그 아웃 요청을 할 때 사용됨
3. UsernamePasswordAuthenticationFilter
    - AuthenticationManager를 통해 로그인 인증 확인
    - UserDetailsService를 통해 확인하고, Authentication 정보를 변경(UserDetails, 비밀번호 초기화)하여 SecurityContext에 저장
    - SecurityContext는 SecurityContextHolder에 저장
    - 인증이 완료되면, 7번으로 이동
4. ConcurrentSessionFilter
    - 세션 동시 제어 설정에 대한 코드를 실행하는 필터
    - 이전 로그인 사용자 세션을 만료, 새로운 사용자 접근 불가
5. RememberMeAuthenticationFilter
    - rememberMe를 사용하는 경우 실행하는 필터
6. AnonymousAuthenticationFilter
    - 익명 사용자 설정에 대한 코드를 실행하는 필터
7. SessionManagementFilter
    - session 정책 설정에 따라 세션에 데이터를 저장 
8. ExceptionTranslationFilter
    - 오류가 발생했을 때 실행하는 필터
    - 인증 예외, 인가 예외를 구분하여 실행 (AuthenticationException, AccessDeniedException)
9. FilterSecurityInterceptor
    - 권한을 체크하는 필터 (Check authenticated)
    - 오류가 발생하면 8번으로 이동

















